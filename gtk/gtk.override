/* -*- Mode: C; c-basic-offset: 4 -*-
 * pygtk- Python bindings for the GTK toolkit.
 * Copyright (C) 1998-2003  James Henstridge
 *
 *   gtk.override: overrides for the gtk module.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
 * USA
 */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"

#include <fcntl.h>
#include <locale.h>

#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gdk-pixbuf/gdk-pixdata.h>

#define PYCAIRO_NO_IMPORT
#include <py3cairo.h>
extern PyTypeObject PyGdkCairoContext_Type;

#include "pygtk-private.h"

#define PYGTK_CONTAINER_FOREACH 0
#define PYGTK_CONTAINER_FORALL 1
#define countof(array) (sizeof(array)/sizeof(array[0]))

/* make GDK_DISPLAY() the case macro */
#undef GDK_DISPLAY
#define GDK_DISPLAY(object) (GDK_DISPLAY_OBJECT(object))

/* from the gdk portion ... */
extern PyTypeObject PyGdkColormap_Type;
extern PyTypeObject PyGdkGC_Type;
extern PyTypeObject PyGdkWindow_Type;
extern PyTypeObject PyGdkPixmap_Type;
extern PyTypeObject PyGdkImage_Type;
extern PyTypeObject PyGdkPixbuf_Type;
extern PyTypeObject PyGdkPixbufAnimation_Type;
extern PyTypeObject PyGdkDragContext_Type;
extern PyTypeObject PyGdkDrawable_Type;
extern PyTypeObject PyGdkDisplay_Type;
extern PyTypeObject PyGdkScreen_Type;
extern PyTypeObject PyGdkRectangle_Type;
extern PyTypeObject PyGdkDevice_Type;

extern PyObject *PyGtkWarning;

#ifndef pyg_add_warning_redirection

static guint _gtk_handler = -1, _gdk_handler = -1, _gdk_pixbuf_handler = -1;

static void
_pygtk_log_func(const gchar *log_domain,
                GLogLevelFlags log_level,
                const gchar *message,
                gpointer user_data)
 {
    if (G_LIKELY(Py_IsInitialized()))
    {
        PyGILState_STATE state;
        
        state = pyg_gil_state_ensure();
        PyErr_Warn(PyGtkWarning, (char *) message);
        pyg_gil_state_release(state);
    } else
        g_log_default_handler(log_domain, log_level, message, user_data);
}

#endif /* ifndef pyg_add_warning_redirection */

static gboolean
pygtk_util_pyobject_as_double(PyObject *obj, gdouble *value, const char *argument_name)
{
    PyObject *number;

    if (!PyNumber_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "'%s' must be a number", argument_name);
        return FALSE;
    }
    number = PyNumber_Float(obj);
    if (!number) {
        PyErr_Format(PyExc_TypeError, "Could not convert '%s' to a float", argument_name);
        return FALSE;
    }
    *value = PyFloat_AsDouble(number);
    Py_DECREF(number);
    return TRUE;
}

static gboolean
_main_quit(GIOChannel* source, GIOCondition condition, gpointer data)
{
    gtk_main_quit();
    return FALSE;
}

static int _loop(void)
{
    PyGILState_STATE gstate;
    GIOChannel* channel;

    /* Watch for input on stdin */
    channel = g_io_channel_unix_new(fileno(stdin));
    g_io_add_watch(channel, G_IO_IN, _main_quit, NULL);
    g_io_channel_unref(channel);

    /* Start the main loop */
    gstate = PyGILState_Ensure();
    gtk_main();
    PyGILState_Release(gstate);

    return 0;
}

%%
include 
  gtkborder.override
  gtkbuilder.override
  gtkclist.override
  gtkcontainer.override
  gtkctree.override
  gtkiconview.override
  gtkrcstyle.override
  gtkstatusbar.override
  gtkstyle.override
  gtktextview.override
  gtktoolbar.override
  gtktreeview.override
  gtkwidget.override
  gtkwindow.override
%%
modulename gtk
%%
import gobject.GObject as PyGObject_Type
import atk.Object as PyAtkObject_Type
import pango.Context as PyPangoContext_Type
import pango.Font as PyPangoFont_Type
import pango.Layout as PyPangoLayout_Type
import gio.File as PyGFile_Type for GFile
import gio.Icon as PyGIcon_Type for GIcon
import gio.MountOperation as PyGMountOperation_Type for GMountOperation
%%
ignore
  gtk_accel_group_connect
  gtk_accel_group_disconnect
  gtk_accel_group_ref
  gtk_accel_group_unref
  gtk_action_group_add_actions_full
  gtk_action_group_add_toggle_actions_full
  gtk_action_group_add_radio_actions_full
  gtk_binding_set_by_class
  gtk_binding_set_clear
  gtk_binding_set_find
  gtk_binding_set_new
  gtk_button_new_from_stock
  gtk_button_new_with_label
  gtk_button_new_with_mnemonic
  gtk_check_button_new_with_label
  gtk_check_button_new_with_mnemonic
  gtk_check_menu_item_new_with_label
  gtk_check_menu_item_new_with_mnemonic
  gtk_clipboard_set_with_owner
  gtk_color_button_new_with_color
  gtk_color_selection_set_color
  gtk_color_selection_get_color
  gtk_combo_box_get_row_separator_func
  gtk_dialog_new
  gtk_dialog_set_alternative_button_order_from_array
  gtk_drag_dest_handle_event
  gtk_drag_source_handle_event
  gtk_drag_finish
  gtk_drag_set_icon_default
  gtk_drag_set_icon_name
  gtk_drag_set_icon_stock
  gtk_drag_set_icon_pixbuf
  gtk_drag_set_icon_pixmap
  gtk_drag_set_icon_widget
  gtk_draw_hline
  gtk_draw_vline
  gtk_draw_shadow
  gtk_draw_polygon
  gtk_draw_arrow
  gtk_draw_diamond
  gtk_draw_box
  gtk_draw_flat_box
  gtk_draw_check
  gtk_draw_option
  gtk_draw_tab
  gtk_draw_shadow_gap
  gtk_draw_box_gap
  gtk_draw_extension
  gtk_draw_focus
  gtk_draw_slider
  gtk_draw_handle
  gtk_draw_expander
  gtk_draw_layout
  gtk_draw_resize_grip
  gtk_draw_string
  gtk_entry_new_with_max_length
  gtk_entry_select_region
  gtk_exit
  gtk_false
  gtk_file_chooser_button_new_with_backend
  gtk_file_chooser_button_new_with_dialog
  gtk_file_chooser_dialog_new_with_backend
  gtk_file_chooser_error_quark
  gtk_file_chooser_dialog_widget_new_with_backend
  gtk_file_system_error_quark
  gtk_file_system_cancel_operation
  gtk_file_paths_copy
  gtk_file_paths_free
  gtk_font_button_new_with_font
  gtk_gc_get
  gtk_gc_release
  gtk_get_event_widget
  gtk_icon_theme_error_quark
  gtk_idle_add
  gtk_idle_add_full
  gtk_idle_add_priority
  gtk_idle_remove
  gtk_idle_remove_by_data
  gtk_image_item_menu_new_with_label
  gtk_image_menu_item_new_from_stock
  gtk_image_menu_item_new_with_mnemonic
  gtk_init
  gtk_init_abi_check
  gtk_init_check_abi_check
  gtk_input_add_full
  gtk_input_remove
  gtk_item_factory_create_item
  gtk_item_factory_create_items_ac
  gtk_item_factory_create_menu_entries
  gtk_item_factory_delete_entries
  gtk_item_factory_delete_entry
  gtk_item_factory_popup_data
  gtk_item_factory_popup_with_data
  gtk_item_factory_set_translate_func
  gtk_key_snooper_install
  gtk_key_snooper_remove
  gtk_list_item_new_with_label
  gtk_list_remove_items_no_unref
  gtk_menu_append
  gtk_menu_bar_append
  gtk_menu_bar_insert
  gtk_menu_bar_prepend
  gtk_menu_insert
  gtk_menu_item_new_with_label
  gtk_menu_item_new_with_mnemonic
  gtk_menu_prepend
  gtk_object_add_arg_type 
  gtk_object_arg_get
  gtk_object_arg_get_info
  gtk_object_args_collect 
  gtk_object_arg_set
  gtk_object_get
  gtk_object_get_data
  gtk_object_get_data_by_id
  gtk_object_get_user_data
  gtk_object_getv
  gtk_object_new 
  gtk_object_newv 
  gtk_object_query_args
  gtk_object_ref
  gtk_object_remove_data_by_id
  gtk_object_remove_no_notify_by_id
  gtk_object_set
  gtk_object_set_data
  gtk_object_set_data_by_id
  gtk_object_set_data_by_id_full
  gtk_object_set_data_full
  gtk_object_set_user_data
  gtk_object_setv
  gtk_object_sink
  gtk_object_unref
  gtk_object_weakref
  gtk_object_weakunref
  gtk_paper_size_free
  gtk_plug_construct
  gtk_plug_construct_for_display
  gtk_preview_uninit
  gtk_preview_get_info
  gtk_print_error_quark
  gtk_progress_bar_new
  gtk_propagate_event
  gtk_quit_remove_by_data
  gtk_radio_button_group
  gtk_radio_menu_item_group
  gtk_radio_menu_item_new_with_label
  gtk_radio_menu_item_new_with_mnemonic
  gtk_range_default_htrough_click
  gtk_range_default_vtrough_click
  gtk_range_trough_click
  gtk_recent_chooser_error_quark
  gtk_recent_chooser_dialog_new_for_manager
  gtk_recent_chooser_menu_new
  gtk_recent_chooser_widget_new
  gtk_recent_chooser_set_show_numbers
  gtk_recent_chooser_get_show_numbers
  gtk_recent_manager_error_quark
  gtk_selection_clear
  gtk_selection_data_copy
  gtk_selection_data_free
  gtk_selection_incr_event
  gtk_selection_notify
  gtk_selection_property_notify
  gtk_selection_request
  gtk_set_locale
  gtk_timeout_remove
  gtk_toggle_button_new_with_label
  gtk_toggle_button_new_with_mnemonic
  gtk_text_anchored_child_set_layout
  gtk_text_child_anchor_queue_resize
  gtk_text_child_anchor_register_child
  gtk_text_child_anchor_unregister_child
  gtk_trace_referencing
  gtk_tree_item_new_with_label
  gtk_tree_remove_items
  gtk_true 
  gtk_rc_find_pixmap_in_path
  gtk_rc_scanner_new
  gtk_rc_parse_color
  gtk_rc_parse_state
  gtk_rc_parse_priority
  gtk_rc_property_parse_color
  gtk_rc_property_parse_enum
  gtk_rc_property_parse_flags
  gtk_rc_property_parse_requisition
  gtk_rc_property_parse_border
  gtk_target_list_new
  gtk_target_list_ref
  gtk_target_list_unref
  gtk_target_list_add
  gtk_target_list_add_table
  gtk_target_list_remove
  gtk_target_list_find
  gtk_target_table_new_from_list
  gtk_target_table_free
  GtkObject__do_set_arg
  GtkObject__do_get_arg
  GtkObject__proxy_do_set_arg
  GtkObject__proxy_do_get_arg
%%
ignore-glob
  _*
  *_get_type
  *_ref
  *_unref
  gtk_arg_*
  gtk_args_*
  gtk_init_add_*
  gtk_marshal_*
  gtk_pattern_*
  gtk_radio_button_new_*
  gtk_quit_add_*
  gtk_signal_*
  gtk_text_layout_*
  gtk_type_*
  gtk_timeout_add*
%%
ignore-type
  GtkFileFolder
  GtkFileInfo
  GtkFileInfoType
  GtkFilePath
  GtkFileSystem
  GtkFileSystemError
  GtkFileSystemHandle
  GtkSignalRunType
  GtkTargetList
  GtkTipsQuery
  GtkTree
  GtkTreeItem
  GtkTreePath
  GtkText
  GtkTextLayout
%%
override gtk_init_check noargs
static PyObject *
_wrap_gtk_init_check(PyGObject *self, PyObject *args)
{
    PyObject *av;
    int argc, i;
    char **argv;

    /* initialise GTK ... */
    /* Don't parse sys.argv for now */
    argc = 0;
    argv = NULL;
#if 0
    av = PySys_GetObject("argv");
    if (av != NULL) {
	if (!PyList_Check(av)) {
	    PyErr_Warn(PyExc_Warning, "ignoring sys.argv: it must be a list of strings");
	    av = NULL;
	} else {
	    argc = PyList_Size(av);
	    for (i = 0; i < argc; i++)
               if (!PyString_Check(PyList_GetItem(av, i))) {
		    PyErr_Warn(PyExc_Warning, "ignoring sys.argv: it must be a list of strings");
		    av = NULL;
		    break;
		}
	}
    }
    if (av != NULL) {
	argv = g_new(char *, argc);
	for (i = 0; i < argc; i++)
           argv[i] = g_strdup(PyString_AsString(PyList_GetItem(av, i)));
    } else {
	    argc = 0;
	    argv = NULL;
    }
#endif

    if (!gtk_init_check(&argc, &argv)) {
	if (argv != NULL) {
	    for (i = 0; i < argc; i++)
		g_free(argv[i]);
	    g_free(argv);
	}
	PyErr_SetString(PyExc_RuntimeError, "could not open display");
	return NULL;
    }
#if 0
    if (argv != NULL) {
	PySys_SetArgv(argc, argv);
	for (i = 0; i < argc; i++)
	    g_free(argv[i]);
	g_free(argv);
    }
#endif

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define set_interactive
static PyObject *
_wrap_set_interactive(PyGObject *self, PyObject *args)
{
    int flag = 1;
    if (!PyArg_ParseTuple(args, "|i", &flag)) return NULL;
    if (flag)
    {
        if (PyOS_InputHook == NULL) {
            PyOS_InputHook = _loop;
        }
        else if (PyOS_InputHook != _loop)
            PyErr_Warn(PyExc_RuntimeWarning, "PyOS_InputHook is not available for interactive use of PyGTK");
    }
    else
    {
        if (PyOS_InputHook == _loop)
            PyOS_InputHook = NULL;
        else if (PyOS_InputHook != NULL)
            PyErr_Warn(PyExc_RuntimeWarning, "PyOS_InputHook was set by a module other than PyGTK");
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
define add_log_handlers
static PyObject *
_wrap_add_log_handlers(PyGObject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ":add_log_handlers"))
	return NULL;
#ifndef pyg_add_warning_redirection

    _gtk_handler = g_log_set_handler("Gtk",
				     G_LOG_LEVEL_CRITICAL|G_LOG_LEVEL_WARNING,
				     _pygtk_log_func, NULL);
    _gdk_handler = g_log_set_handler("Gdk",
				     G_LOG_LEVEL_CRITICAL|G_LOG_LEVEL_WARNING,
				     _pygtk_log_func, NULL);
    _gdk_pixbuf_handler = g_log_set_handler("GdkPixbuf",
					    G_LOG_LEVEL_CRITICAL|G_LOG_LEVEL_WARNING,
					    _pygtk_log_func, NULL);
#else

    pyg_add_warning_redirection("Gtk", PyGtkWarning);
    pyg_add_warning_redirection("Gdk", PyGtkWarning);
    pyg_add_warning_redirection("GdkPixbuf", PyGtkWarning);

#endif /* ifndef pyg_add_warning_redirection */

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define remove_log_handlers
static PyObject *
_wrap_remove_log_handlers(PyGObject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ":remove_log_handlers"))
	return NULL;

#ifndef pyg_disable_warning_redirections

    g_log_remove_handler("Gtk", _gtk_handler);
    _gtk_handler = -1;
    g_log_remove_handler("Gdk", _gdk_handler);
    _gdk_handler = -1;
    g_log_remove_handler("GdkPixbuf", _gdk_pixbuf_handler);
    _gdk_pixbuf_handler = -1;

#else

    pyg_disable_warning_redirections();

#endif /* ifndef pyg_disable_warning_redirections */

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gtk_paint_polygon kwargs
static PyObject *
_wrap_gtk_paint_polygon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "points", "fill", NULL };
    PyObject *window, *py_state_type, *py_shadow_type, *py_area;
    GtkStateType state_type;
    GtkShadowType shadow_type;
    GdkRectangle area;
    PyObject *widget;
    const gchar *detail;
    PyObject *py_points;
    gint npoints, i;
    GdkPoint *points;
    gboolean fill;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "O!OOOO!zOi:GdkStyle.paint_polygon",
                                     kwlist, &PyGdkWindow_Type, &window,
                                     &py_state_type, &py_shadow_type, &py_area,
                                     &PyGtkWidget_Type, &widget, &detail,
                                     &py_points, &fill))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type,
                           (gint *)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type,
                           (gint *)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (!PySequence_Check(py_points)) {
        PyErr_SetString(PyExc_TypeError, "points must be a sequence");
        return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
        PyObject *item = PySequence_GetItem(py_points, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "hh", &points[i].x, &points[i].y)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "sequence members must be 2-tuples");
            g_free(points);
            return NULL;
        }
    }
    gtk_paint_polygon(GTK_STYLE(self->obj), GDK_WINDOW(pygobject_get(window)),
                      state_type, shadow_type, &area,
                      GTK_WIDGET(pygobject_get(widget)), detail,
                      points, npoints, fill);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override-attr GtkSelectionData.data
static PyObject *
_wrap_gtk_selection_data__get_data(PyGObject *self, void *closure)
{
    if (pyg_boxed_get(self, GtkSelectionData)->length >= 0) {
        return PyBytes_FromStringAndSize(
	    (char*)pyg_boxed_get(self, GtkSelectionData)->data,
	    pyg_boxed_get(self, GtkSelectionData)->length);
    } else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gtk_selection_data_set kwargs
static PyObject *
_wrap_gtk_selection_data_set(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", "format", "data", NULL };
    PyObject *py_type;
    GdkAtom type;
    int format;
    Py_ssize_t length;
    guchar *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oiy#:GtkSelectionData.set", kwlist,
                                     &py_type, &format, &data, &length))
        return NULL;
    type = pygdk_atom_from_pyobject(py_type);
    if (PyErr_Occurred())
        return NULL;

    gtk_selection_data_set(pyg_boxed_get(self, GtkSelectionData),
                           type, format, data, length);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_selection_data_get_text noargs
static PyObject *
_wrap_gtk_selection_data_get_text(PyObject *self)
{
    gchar *ret;

    ret = (char*)gtk_selection_data_get_text(pyg_boxed_get(self,
							   GtkSelectionData));
    if (ret) {
        PyObject *py_ret = PyUnicode_DecodeUTF8(ret, strlen(ret), "strict");
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_selection_data_get_targets noargs
static PyObject *
_wrap_gtk_selection_data_get_targets(PyObject *self)
{
    GdkAtom *targets;
    gint n_atoms;

    if (gtk_selection_data_get_targets(pyg_boxed_get(self, GtkSelectionData),
                                       &targets, &n_atoms)) {
        PyObject *ret;
        gint i;

        ret = PyTuple_New(n_atoms);
        for (i = 0; i < n_atoms; i++) {
            gchar *name = gdk_atom_name(targets[i]);

            PyTuple_SetItem(ret, i, PyUnicode_FromString(name));
            g_free(name);
        }
        g_free(targets);
        return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_set_with_data kwargs
static void
clipboard_get_func(GtkClipboard *clipboard, GtkSelectionData *selection_data,
		   guint info, gpointer user_data)
{
    PyObject *callback, *args, *ret;
    PyGILState_STATE state;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNiO)",
			 pygobject_new((GObject *)clipboard),
			 pyg_boxed_new(GTK_TYPE_SELECTION_DATA,
				       selection_data, FALSE, FALSE),
			 info, PyTuple_GetItem((PyObject *)user_data, 2));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    pyg_gil_state_release(state);
}
static void
clipboard_clear_func(GtkClipboard *clipboard, gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 1);
    args = Py_BuildValue("(NO)",
			 pygobject_new((GObject *)clipboard),
			 PyTuple_GetItem((PyObject *)user_data, 2));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF((PyObject *)user_data);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_set_with_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "get_func", "clear_func", "user_data", NULL };
    PyObject *py_targets, *get_func, *clear_func = Py_None, *user_data = Py_None;
    GtkTargetEntry *targets;
    gint n_targets, i;
    gboolean ret;
    PyObject *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|OO:GtkClipboard.set_with_data",kwlist,
                                     &py_targets, &get_func, &clear_func,
				     &user_data))
        return NULL;
    if (!PyCallable_Check(get_func)) {
	PyErr_SetString(PyExc_TypeError, "get_func must be callable");
	return NULL;
    }
    if (clear_func != Py_None && !PyCallable_Check(clear_func)) {
	PyErr_SetString(PyExc_TypeError,"clear_func must be callable or None");
	return NULL;
    }
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    data = Py_BuildValue("(OOO)", get_func, clear_func, user_data);
    ret = gtk_clipboard_set_with_data(GTK_CLIPBOARD(self->obj),
				      targets, n_targets,
				      clipboard_get_func, clipboard_clear_func,
				      data);
    g_free(targets);
    Py_DECREF(py_targets);
    if (!ret) {
	Py_DECREF(data);
    }

    return PyBool_FromLong(ret);
}
%%
override gtk_label_get noargs
static PyObject *
_wrap_gtk_label_get(PyGObject *self)
{
    gchar *text = NULL;

    gtk_label_get(GTK_LABEL(self->obj), &text);
    if (text)
        return PyUnicode_FromString(text);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_label_get_selection_bounds noargs
static PyObject *
_wrap_gtk_label_get_selection_bounds(PyGObject *self)
{
    int start, end;

    if (!gtk_label_get_selection_bounds(GTK_LABEL(self->obj), &start, &end)) {
       return Py_BuildValue ("()");
    }

    return Py_BuildValue("(ii)", start, end);
}
%%
override gtk_label_get_layout_offsets noargs
static PyObject *
_wrap_gtk_label_get_layout_offsets(PyGObject *self)
{
    gint x;
    gint y;

    gtk_label_get_layout_offsets(GTK_LABEL(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_spin_button_get_increments noargs
static PyObject *
_wrap_gtk_spin_button_get_increments(PyGObject *self)
{
    gdouble step;
    gdouble page;

    gtk_spin_button_get_increments(GTK_SPIN_BUTTON(self->obj), &step, &page);
    return Py_BuildValue("(dd)", step, page);
}
%%
override gtk_spin_button_get_range noargs
static PyObject *
_wrap_gtk_spin_button_get_range(PyGObject *self)
{
    gdouble min;
    gdouble max;

    gtk_spin_button_get_range(GTK_SPIN_BUTTON(self->obj), &min, &max);
    return Py_BuildValue("(dd)", min, max);
}
%%
override gtk_box_query_child_packing kwargs
static PyObject *
_wrap_gtk_box_query_child_packing(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *pychild;
    GtkWidget *child;
    GList *children;
    gboolean expand, fill;
    guint padding;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!:GtkBox.query_child_packing", kwlist,
                                     &PyGtkWidget_Type, &pychild)) {
        return NULL;
    }

    child = GTK_WIDGET(pychild->obj);
    children = gtk_container_get_children(GTK_CONTAINER(self->obj));
    if (g_list_find(children, child) == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a child");
        return NULL;
    }
    gtk_box_query_child_packing(GTK_BOX(self->obj),
                                child, &expand, &fill,
                                &padding, &pack_type);
    return Py_BuildValue("(iiiN)", (int)expand, (int)fill, padding,
			 pyg_enum_from_gtype(GTK_TYPE_PACK_TYPE, pack_type));
}
%%
override gtk_combo_set_popdown_strings kwargs
static PyObject *
_wrap_gtk_combo_set_popdown_strings(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "strings", NULL };
    PyObject *list;
    GList *glist = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkCombo.set_popdown_strings", kwlist,
                                     &list))
        return NULL;
    if (!PySequence_Check(list)) {
        PyErr_SetString(PyExc_TypeError, "first argument must be a sequence");
        return NULL;
    }
    len = PySequence_Length(list);
    for (i = 0; i < len; i++) {
        PyObject *item = PySequence_GetItem(list, i);

        Py_DECREF(item);
        if (!PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "sequence item not a string");
            g_list_free(glist);
            return NULL;
        }
        glist = g_list_append(glist, PyUnicode_AsUTF8(item));
    }
    gtk_combo_set_popdown_strings(GTK_COMBO(self->obj), glist);
    g_list_free(glist);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_curve_get_vector kwargs
static PyObject *
_wrap_gtk_curve_get_vector(PyGObject *self, PyObject *args,
                           PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    int size = -1, i;
    gfloat *vector;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|i:GtkCurve.get_vector", kwlist,
                                     &size))
        return NULL;
    if (size < 0) size = GTK_CURVE(self->obj)->num_points;
    vector = g_new(gfloat, size);
    gtk_curve_get_vector(GTK_CURVE(self->obj), size, vector);
    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
        PyTuple_SetItem(ret, i, PyFloat_FromDouble(vector[i]));
    g_free(vector);
    return ret;
}
%%
override gtk_curve_set_vector kwargs
static PyObject *
_wrap_gtk_curve_set_vector(PyGObject *self, PyObject *args,
                           PyObject *kwargs)
{
    static char *kwlist[] = { "vector", NULL };
    PyObject *seq;
    int size, i;
    gfloat *vector;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCurve.set_vector",
                                     kwlist, &seq))
        return NULL;
    if (!PySequence_Check(seq)) {
        PyErr_SetString(PyExc_TypeError, "1st argument is not a sequence");
        return NULL;
    }
    size = PySequence_Length(seq);
    vector = g_new(gfloat, size);
    for (i = 0; i < size; i++) {
        PyObject *item = PySequence_GetItem(seq, i);

        Py_DECREF(item);
        item = PyNumber_Float(item); /* item has a ref now */
        if (item == NULL) {
            g_free(vector);
            return NULL;
        }
        vector[i] = PyFloat_AsDouble(item);
        Py_DECREF(item);
    }
    gtk_curve_set_vector(GTK_CURVE(self->obj), size, vector);
    g_free(vector);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_binding_entry_add_signal
static PyObject *
_wrap_gtk_binding_entry_add_signal(PyGObject *self, PyObject *args)
{
    PyObject *first;
    gint len, i;
    PyObject *class;
    guint keyval, modifiers;
    gchar *signal_name;
    GType class_type;
    GtkBindingSet *bset = NULL;
    GSList *slist = NULL;
    gchar *errmsg;

    len = PyTuple_Size(args);
    if (len < 4) {
        PyErr_SetString(PyExc_TypeError, "binding_entry_add_signal requires at"
                        " least 4 arguments");
        return NULL;
    }
    first = PySequence_GetSlice(args, 0, 4);
    if (!PyArg_ParseTuple(first, "Oiis:binding_entry_add_signal", &class,
                          &keyval, &modifiers, &signal_name)) {
        Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);

    class_type = pyg_type_from_object(class);
    if (class_type == 0)
        return NULL;

    bset = gtk_binding_set_by_class(gtk_type_class(class_type));

    /* extra args */
    if ((len-4)%2) {
        PyErr_SetString(PyExc_ValueError,
                        "GtkBindingSet.add_signal requires an even number"
                        " of parameter pairs following the first four args");
        return NULL;
    }
    for (i=4; i < len; i+=2) {
        PyObject *item;
        GType arg_type;
        GtkBindingArg *arg = NULL;

        item = PyTuple_GET_ITEM(args, i);
        arg_type = pyg_type_from_object(item);
        if (!arg_type) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "GtkBindingSet.add_signal parameter types"
                            " must be int");
            goto arg_error;
        }
        arg = g_new0 (GtkBindingArg, 1);
        slist = g_slist_prepend(slist, arg);

        arg->arg_type = arg_type;
        switch (GTK_FUNDAMENTAL_TYPE(arg->arg_type)) {
        case GTK_TYPE_CHAR:
        case GTK_TYPE_UCHAR:
        case GTK_TYPE_INT:
        case GTK_TYPE_UINT:
        case GTK_TYPE_BOOL:
        case GTK_TYPE_ENUM:
        case GTK_TYPE_FLAGS:
        case GTK_TYPE_LONG:
        case GTK_TYPE_ULONG:
            arg->arg_type = GTK_TYPE_LONG;
            item = PyTuple_GET_ITEM(args, i+1);
            if (!PyLong_Check(item)) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal "
                                         "arg[%u] must be int", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            arg->d.long_data = (glong)PyLong_AsLong(item);
            break;
        case GTK_TYPE_FLOAT:
        case GTK_TYPE_DOUBLE:
            arg->arg_type = GTK_TYPE_DOUBLE;
            item = PyTuple_GET_ITEM(args, i+1);
            if (!PyFloat_Check(item)) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal "
                                         "arg[%u] must be float", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            arg->d.double_data = (gdouble)PyFloat_AsDouble(item);
            break;
        case GTK_TYPE_STRING:
            arg->arg_type = GTK_TYPE_STRING;
            if (arg->arg_type != GTK_TYPE_IDENTIFIER)
                arg->arg_type = GTK_TYPE_STRING;
            item = PyTuple_GET_ITEM(args, i+1);
            if (!PyUnicode_Check(item)) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
                                         "must be non-empty string", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            arg->d.string_data = (gchar*)PyUnicode_AsUTF8(item);
            if (!arg->d.string_data) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
                                         "must be non-empty string", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            break;
        default:
            errmsg = g_strdup_printf("GtkBindingSet.add_signal unsupported "
                                     "type %10s for arg[%u]",
                                     gtk_type_name(arg->arg_type), i+1);
            PyErr_SetString(PyExc_TypeError, errmsg);
            g_free(errmsg);
            goto arg_error;
        } /* switch */
    }

    slist = g_slist_reverse (slist);
    gtk_binding_entry_add_signall (bset, keyval,modifiers, signal_name, slist);

    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);

    Py_INCREF(Py_None);
    return Py_None;

arg_error:
    if (slist) {
        g_slist_foreach(slist, (GFunc)g_free, NULL);
        g_slist_free(slist);
    }
    return NULL;
}
%%
override gtk_main noargs

  /* This code (pygtk main watch) was copied with minor changes from
   * pygobject/gobject/pygmainloop.c */

static int pipe_fds[2];

typedef struct {
    GSource source;
    GPollFD fd;
} PySignalWatchSource;

static gboolean
pygtk_main_watch_prepare(GSource *source,
                         int     *timeout)
{
    /* Python only invokes signal handlers from the main thread,
     * so if a thread other than the main thread receives the signal
     * from the kernel, PyErr_CheckSignals() from that thread will
     * do nothing.
     */

#ifdef HAVE_PYSIGNAL_SETWAKEUPFD
    return FALSE;
#else /* !HAVE_PYSIGNAL_SETWAKEUPFD */
    /* On Windows g_poll() won't be interrupted by a signal
     * (AFAIK), so we need the timeout there too, even if there's
     * only one thread.
     */
#ifndef PLATFORM_WIN32
    if (!pyg_threads_enabled)
        return FALSE;
#endif /* PLATFORM_WIN32 */

    /* If we're using 2.5 or an earlier version of python we
     * will default to a timeout every second, be aware,
     * this will cause unnecessary wakeups, see
     * http://bugzilla.gnome.org/show_bug.cgi?id=481569
     */
    *timeout = 1000;
    return FALSE;
#endif /* HAVE_PYSIGNAL_SETWAKEUPFD */
}

static gboolean
pygtk_main_watch_check(GSource *source)
{
    PyGILState_STATE state;

#ifdef HAVE_PYSIGNAL_SETWAKEUPFD
    PySignalWatchSource *real_source = (PySignalWatchSource *)source;
    GPollFD *poll_fd = &real_source->fd;
    unsigned char dummy;
    gssize ret;
    if (poll_fd->revents & G_IO_IN)
        ret = read(poll_fd->fd, &dummy, 1);
#endif

    state = pyg_gil_state_ensure();

    if (PyErr_CheckSignals() == -1 && gtk_main_level() > 0) {
        PyErr_SetNone(PyExc_KeyboardInterrupt);
        gtk_main_quit();
    }

    pyg_gil_state_release(state);

    return FALSE;
}

static gboolean
pygtk_main_watch_dispatch(GSource    *source,
			  GSourceFunc callback,
			  gpointer    user_data)
{
    /* We should never be dispatched */
    g_assert_not_reached();
    return TRUE;
}

static GSourceFuncs pygtk_main_watch_funcs =
{
    pygtk_main_watch_prepare,
    pygtk_main_watch_check,
    pygtk_main_watch_dispatch
};

static GSource *
pygtk_main_watch_new(void)
{
    GSource *source = g_source_new(&pygtk_main_watch_funcs, sizeof(PySignalWatchSource));

#ifdef HAVE_PYSIGNAL_SETWAKEUPFD
    PySignalWatchSource *real_source = (PySignalWatchSource *)source;
    int flag;

    /* Unfortunately we need to create a new pipe here instead of
     * reusing the pipe inside the GMainContext.
     * Ideally an api should be added to GMainContext which allows us
     * to reuse that pipe which would suit us perfectly fine.
     * XXX More efficient than a pipe, we could use an eventfd on Linux
     * kernels that support it.
     */
    gint already_piped = (pipe_fds[0] > 0);
    if (!already_piped) {
	if (pipe(pipe_fds) < 0)
	    g_error("Cannot create main loop pipe: %s\n",
	            g_strerror(errno));

        /* Make the write end of the fd non blocking */
        flag = fcntl(pipe_fds[1], F_GETFL, 0);
        flag |= O_NONBLOCK;
        fcntl(pipe_fds[1], F_SETFL, flag);
    }

    real_source->fd.fd = pipe_fds[0];
    real_source->fd.events = G_IO_IN | G_IO_HUP | G_IO_ERR;
    g_source_add_poll(source, &real_source->fd);

    if (!already_piped)
      PySignal_SetWakeupFd(pipe_fds[1]);
#endif
    return source;
}


static PyObject *
_wrap_gtk_main(PyObject *self)
{
    GSource *main_watch;
    // Call enable_threads again to ensure that the thread state is recorded
    if (pyg_threads_enabled)
	pyg_enable_threads();

    main_watch = pygtk_main_watch_new();
    pyg_begin_allow_threads;
    g_source_attach(main_watch, NULL);
    g_source_unref(main_watch);
    gtk_main();
    g_source_destroy(main_watch);
    pyg_end_allow_threads;
    if (PyErr_Occurred())
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_main_iteration kwargs
static PyObject *
_wrap_gtk_main_iteration(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"block", NULL};
    int block = 1, ret;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:main_iteration", kwlist,
                                    &block))
        return NULL;
    pyg_begin_allow_threads;
    ret = gtk_main_iteration_do(block);
    pyg_end_allow_threads;

    return PyBool_FromLong(ret);
}
%%
override gtk_main_quit args
static PyObject *
_wrap_gtk_main_quit(PyObject *self, PyObject *args)
{
    /* args is just ignored, so obj.connect(signal, func) always works */

    /* Sanity check to make sure we're in a mainloop */
    if (gtk_main_level() == 0) {
	PyErr_SetString(PyExc_RuntimeError,
			"called outside of a mainloop");
	return NULL;
    }
	
    gtk_main_quit();
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_main_iteration_do kwargs
static PyObject *
_wrap_gtk_main_iteration_do(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"block", NULL};
    int block = 1, ret;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:main_iteration_do",
                                    kwlist, &block))
        return NULL;

    pyg_begin_allow_threads;
    ret = gtk_main_iteration_do(block);
    pyg_end_allow_threads;

    return PyBool_FromLong(ret);
}
%%
override gtk_quit_add
static gboolean
quit_handler_marshal(gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *tuple, *ret;
    gboolean res;

    g_return_val_if_fail(user_data != NULL, FALSE);

    state = pyg_gil_state_ensure();

    tuple = (PyObject *)user_data;
    ret = PyObject_CallObject(PyTuple_GetItem(tuple, 0),
                              PyTuple_GetItem(tuple, 1));
    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }
    pyg_gil_state_release(state);

    return res;
}

static PyObject *
_wrap_gtk_quit_add(PyObject *self, PyObject *args)
{
    gint main_level;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
        PyErr_SetString(PyExc_TypeError,
                        "quit_add requires at least 2 args");
        return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:quit_add", &main_level, &callback)) {
        Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second argument not callable");
        return NULL;
    }

    cbargs = PySequence_GetSlice(args, 2, len);
    if (cbargs == NULL)
      return NULL;

    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyLong_FromLong(gtk_quit_add_full(main_level, quit_handler_marshal,
                                            NULL, data, pyg_destroy_notify));
}
%%
override gtk_get_current_event_state noargs
static PyObject *
_wrap_gtk_get_current_event_state (PyGObject *self)
{
    GdkModifierType state = 0;

    if (gtk_get_current_event_state (&state)) {
	return pyg_flags_from_gtype (GDK_TYPE_MODIFIER_TYPE, state);
    } else {
	Py_INCREF (Py_None);
	return Py_None;
    }
}
%%
override gtk_editable_insert_text kwargs
static PyObject *
_wrap_gtk_editable_insert_text(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "text", "position", NULL };
    char *text;
    Py_ssize_t len;
    int position=0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s#|i:GtkEditable.insert_text",
                                     kwlist, &text, &len, &position))
        return NULL;
    gtk_editable_insert_text(GTK_EDITABLE(self->obj), text, len, &position);
    return PyLong_FromLong(position);
}
%%
override gtk_editable_get_selection_bounds noargs
static PyObject *
_wrap_gtk_editable_get_selection_bounds(PyGObject *self, PyObject *args)
{
    int start, end;

    if (!gtk_editable_get_selection_bounds(GTK_EDITABLE(self->obj), &start, &end)) {
            return Py_BuildValue ("()");
    }

    return Py_BuildValue ("(ii)", start, end);
}
%%
override gtk_entry_get_layout_offsets noargs
static PyObject *
_wrap_gtk_entry_get_layout_offsets(PyGObject *self, PyObject *args)
{
    int x, y;

    gtk_entry_get_layout_offsets(GTK_ENTRY(self->obj), &x, &y);

    return Py_BuildValue ("(ii)", x, y);
}
%%
override gtk_item_factory_create_items kwargs
static void
pygtk_item_factory_cb(PyGtkCustomNotify *cunote,
                      guint action, GtkWidget *widget)
{
    PyGILState_STATE state;
    PyObject *ret;

    state = pyg_gil_state_ensure();
    if (cunote->data)
        ret = PyObject_CallFunction(cunote->func, "OiO", cunote->data, action,
                                    pygobject_new((GObject *)widget));
    else
        ret = PyObject_CallFunction(cunote->func, "iO", action,
                                    pygobject_new((GObject *)widget));
    if (ret == NULL) {
        PyErr_Print();
    } else
        Py_DECREF(ret);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_item_factory_create_items(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "callback_data", NULL };
    PyObject *list, *cb, *cbdata = NULL;
    GtkItemFactoryEntry ent;
    PyObject *extra_data = NULL;
    GtkItemFactory *ifact;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkItemFactory.create_items", kwlist,
                                     &list, &cbdata))
        return NULL;

    if (!PySequence_Check(list)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    ifact = GTK_ITEM_FACTORY(self->obj);
    len = PySequence_Size(list);
    for (i = 0; i < len; i++) {
        PyGtkCustomNotify *cunote = NULL;
        PyObject *item = PySequence_GetItem(list, i);
        Py_DECREF(item);

        memset(&ent, 0, sizeof(ent));
        cb = Py_None;

        if (!PyArg_ParseTuple(item, "s|zOizO", &(ent.path), &(ent.accelerator),
                              &cb, &(ent.callback_action), &(ent.item_type),
                              &extra_data)) {
            return NULL;
        }

        if (cb == Py_None) {
            ent.callback = NULL;
        } else {
            ent.callback = (GtkItemFactoryCallback)pygtk_item_factory_cb;
            cunote = g_new0(PyGtkCustomNotify, 1);
            cunote->func = cb;
            cunote->data = cbdata;
            Py_XINCREF(cunote->func);
            Py_XINCREF(cunote->data);
        }

        if (extra_data != NULL) {
            if (PyUnicode_Check(extra_data)) {
                ent.extra_data = PyUnicode_AsUTF8(extra_data);
            } else if (pygobject_check(extra_data, &PyGdkPixbuf_Type)) {
		/* create_items actually expects inline image data 
		 * so let's create it for the user from the pixbuf
		 * it's not optimal but it's convenient
		 */  
		GdkPixdata pixdata; 
		GdkPixbuf * pixbuf;
		guint8 * serialstr;
		guint len;
		
		pixbuf = GDK_PIXBUF(pygobject_get(extra_data));
		gdk_pixdata_from_pixbuf(&pixdata, pixbuf, FALSE);
		serialstr = gdk_pixdata_serialize(&pixdata, &len);
                ent.extra_data = serialstr;
            } else {
                PyErr_SetString(PyExc_TypeError,
                                "last argument must be a GdkPixBuf or a string");
                return NULL;
            }
        }
        if (cunote != NULL) {
	    PyGILState_STATE state;
	    state = pyg_gil_state_ensure();
            g_object_weak_ref(G_OBJECT(ifact),
                              (GWeakNotify) pygtk_custom_destroy_notify,
                              cunote);
	    pyg_gil_state_release(state);
        }

        gtk_item_factory_create_item(ifact, &ent, cunote, 1);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_menu_popup kwargs
static void
pygtk_menu_position(GtkMenu *menu, int *x, int *y, gboolean *push_in,
                    gpointer user_data)
{
    PyGtkCustomNotify *cunote = (PyGtkCustomNotify*)user_data;
    PyObject *ret;
    PyGILState_STATE state;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    if (cunote->data) {
        ret = PyObject_CallFunction(cunote->func, "(NO)",
                                    pygobject_new((GObject *)menu),
                                    cunote->data);
    } else {
        ret = PyObject_CallFunction(cunote->func, "(N)",
                                    pygobject_new((GObject *)menu));
    }

    if (ret == NULL || !PyArg_ParseTuple(ret, "iii", x, y, push_in)) {
        PyErr_Print();
        Py_XDECREF(ret);
    } else {
        Py_DECREF(ret);
    }
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_menu_popup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent_menu_shell", "parent_menu_item", "func",
                       "button", "activate_time", "data", NULL };
    PyGObject *py_pms, *py_pmi;
    GtkWidget *pms = NULL, *pmi = NULL;
    GtkMenu *menu = GTK_MENU(self->obj);
    PyObject *func, *data = NULL;
    int button;
    guint32 time;
    PyObject *pytime;
    PyGtkCustomNotify *cunote;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,  "OOOiO|O:GtkMenu.popup",
                                     kwlist, &py_pms, &py_pmi, &func,
                                     &button, &pytime, &data))
        return NULL;
    if (pygobject_check(py_pms, &PyGtkWidget_Type))
        pms = GTK_WIDGET(py_pms->obj);
    else if ((PyObject *)py_pms != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "parent_menu_shell must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_pmi, &PyGtkWidget_Type))
        pmi = GTK_WIDGET(py_pmi->obj);
    else if ((PyObject *)py_pmi != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "parent_menu_item must be a GtkWidget or None");
        return NULL;
    }
    if (!PyCallable_Check(func) && func != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "func must be a callable object or None");
        return NULL;
    }
    if (PyLong_Check(pytime)) {
	time = PyLong_AsUnsignedLong(pytime);
	if (PyErr_Occurred())
	    return NULL;
    } else {
        PyErr_SetString(PyExc_TypeError,
                        "last argument must be int or long");
        return NULL;
    }

    /* this is an ugly hack to avoid leaking memory and references
       gtk_menu_popup should use a data destroy function */
    if (menu->position_func == pygtk_menu_position) {
        cunote = menu->position_func_data;
        Py_DECREF(cunote->func);
        Py_XDECREF(cunote->data);
        g_free(cunote);
    }
    if (func != Py_None) {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = func;
        cunote->data = data;
        Py_INCREF(func);
        Py_XINCREF(data);
        gtk_menu_popup(GTK_MENU(self->obj), pms, pmi,
                       (GtkMenuPositionFunc)pygtk_menu_position,
                       cunote, button, time);
    } else
        gtk_menu_popup(GTK_MENU(self->obj), pms, pmi, NULL,NULL, button,time);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_pixmap_get noargs
static PyObject *
_wrap_gtk_pixmap_get(PyGObject *self)
{
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    gtk_pixmap_get(GTK_PIXMAP(self->obj), &pixmap, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
                         pygobject_new((GObject *)mask));
}

%%
override gtk_button_new kwargs
static int
_wrap_gtk_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", "stock", "use_underline", NULL };
    gchar *text = NULL, *stock = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|zzO:OGtkButton.__init__",
                                     kwlist, &text, &stock, &py_use_underline))
        return -1;
    if (stock)
        pygobject_construct(self,
                            "label", stock, "use-stock", TRUE,
                            "use-underline", TRUE, NULL);
    else
        pygobject_construct(self,
                            "label", text, "use-underline",
                            PyObject_IsTrue(py_use_underline), NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkButton object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_BUTTON
%%
override gtk_button_get_alignment noargs
static PyObject *
_wrap_gtk_button_get_alignment(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_button_get_alignment(GTK_BUTTON(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
%%
override gtk_button_box_get_child_size noargs
static PyObject *
_wrap_gtk_button_box_get_child_size(PyGObject *self)
{
    gint min_width;
    gint min_height;

    if (PyErr_Warn(PyExc_DeprecationWarning, "don't use this") < 0)
        return NULL;
    gtk_button_box_get_child_size(GTK_BUTTON_BOX(self->obj), &min_width, &min_height);
    return Py_BuildValue("(ii)", min_width, min_height);
}
%%
override gtk_button_box_get_child_ipadding noargs
static PyObject *
_wrap_gtk_button_box_get_child_ipadding(PyGObject *self)
{
    gint ipad_x;
    gint ipad_y;

    if (PyErr_Warn(PyExc_DeprecationWarning, "don't use this") < 0)
        return NULL;
    gtk_button_box_get_child_ipadding(GTK_BUTTON_BOX(self->obj), &ipad_x, &ipad_y);
    return Py_BuildValue("(ii)", ipad_x, ipad_y);
}
%%
override gtk_toggle_button_new kwargs
static int
_wrap_gtk_toggle_button_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zO:GtkToggleButton.__init__", kwlist,
                                     &text, &py_use_underline))
        return -1;
    if (text)
        pygobject_construct(self,
                            "label", text, "use-underline",
                            PyObject_IsTrue(py_use_underline), NULL);
    else
        pygobject_construct(self, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkToggleButton object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_TOGGLE_BUTTON
%%
override gtk_check_button_new kwargs
static int
_wrap_gtk_check_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|zO:GtkCheckButton.__init__",
                                     kwlist, &text, &py_use_underline))
        return -1;
    if (text)
        pygobject_construct(self,
                            "label", text, "use-underline",
                            PyObject_IsTrue(py_use_underline), NULL);
    else
        pygobject_construct(self, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkCheckButton object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_CHECK_BUTTON
%%
override gtk_radio_button_new kwargs
static int
_wrap_gtk_radio_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "group", "label", "use_underline", NULL };
    PyObject *py_group = Py_None;
    gchar *label = NULL;
    GtkRadioButton *group;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"|OzO:GtkRadioButton.__init__",
                                     kwlist, &py_group, &label,
                                     &py_use_underline))
        return -1;
    if (py_group == Py_None)
        group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioButton_Type))
        group = GTK_RADIO_BUTTON(pygobject_get(py_group));
    else {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkRadioButton or None");
        return -1;
    }
    /* various configs for create radio buttons ... */
    if (label == NULL) {
        if (group == NULL)
            pygobject_construct(self, NULL);
        else
            pygobject_construct(self, "group", group, NULL);
    } else {
        if (group == NULL)
            pygobject_construct(self,
                                "label", label, "use-underline",
                                PyObject_IsTrue(py_use_underline), NULL);
        else
            pygobject_construct(self,
                                "label", label, "group", group,
                                "use-underline",
                                PyObject_IsTrue(py_use_underline), NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioButton object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_RADIO_BUTTON
%%
override gtk_radio_button_get_group noargs
static PyObject *
_wrap_gtk_radio_button_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
%%
override gtk_list_item_new kwargs
static int
_wrap_gtk_list_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.TreeView") < 0)
        return -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkListItem.__init__",
                                     kwlist, &text))
        return -1;
    if (text)
        self->obj = (GObject *)gtk_list_item_new_with_label(text);
    else
        self->obj = (GObject *)gtk_list_item_new();
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkListItem object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_menu_item_new kwargs
static int
_wrap_gtk_menu_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|zO:GtkMenuItem.__init__",
                                     kwlist, &text, &py_use_underline))
        return -1;
    pygobject_construct(self, NULL);
    if (text) {
        GtkWidget *accel_label;
        accel_label = g_object_new(GTK_TYPE_ACCEL_LABEL, NULL);
        gtk_misc_set_alignment(GTK_MISC(accel_label), 0.0, 0.5);
        gtk_container_add(GTK_CONTAINER(self->obj), accel_label);
        if (PyObject_IsTrue(py_use_underline))
            gtk_label_set_text_with_mnemonic(GTK_LABEL(accel_label), text);
        else
            gtk_label_set_text(GTK_LABEL(accel_label), text);
        gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(accel_label),
                                         GTK_WIDGET(self->obj));
        gtk_widget_show(accel_label);
     }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkMenuItem object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_MENU_ITEM
%%
override gtk_menu_attach_to_widget kwargs
static void
pygtk_menu_detach (GtkWidget *attach_widget, GtkMenu *menu)
{
    PyGILState_STATE state;
    PyObject *func;
    PyObject *ret;

    func = g_object_get_data (G_OBJECT (menu), "pygtk_menu_detach_func");

    if (!func)
        return;

    state = pyg_gil_state_ensure();

    ret = PyObject_CallFunction (func, "OO",
                                 pygobject_new ((GObject *) menu),
                                 pygobject_new ((GObject *) attach_widget));
    if (ret == NULL) {
        PyErr_Print ();
        Py_XDECREF (ret);
    }
    else
        Py_DECREF (ret);

    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_menu_attach_to_widget (PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "attach_widget", "detach_func", NULL };
    PyGObject *py_attach_widget;
    PyObject *detach_func;
    GtkWidget *attach_widget;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O!O:GtkMenu.attach_to_widget",
                                      kwlist, &PyGtkWidget_Type,
                                      &py_attach_widget, &detach_func))
        return NULL;

    attach_widget = GTK_WIDGET (py_attach_widget->obj);

    if (!PyCallable_Check (detach_func) && detach_func != Py_None) {
        PyErr_SetString (PyExc_TypeError, "second argument not callable");
        return NULL;
    }

    if (detach_func != Py_None) {
        Py_INCREF (detach_func);
        g_object_set_data_full (self->obj,
                                "pygtk_menu_detach_func",
                                detach_func,
                                pyg_destroy_notify);
    }
    else
        g_object_set_data (self->obj, "pygtk_menu_detach_func", NULL);

    gtk_menu_attach_to_widget (GTK_MENU (self->obj), attach_widget,
                               (GtkMenuDetachFunc) pygtk_menu_detach);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override gtk_check_menu_item_new kwargs
static int
_wrap_gtk_check_menu_item_new(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zO:GtkCheckMenuItem.__init__", kwlist,
                                     &text, &py_use_underline))
        return -1;
    pygobject_construct(self, NULL);
    if (text) {
        GtkWidget *accel_label;
        accel_label = g_object_new(GTK_TYPE_ACCEL_LABEL, NULL);
        gtk_misc_set_alignment(GTK_MISC(accel_label), 0.0, 0.5);
        gtk_container_add(GTK_CONTAINER(self->obj), accel_label);
        if (PyObject_IsTrue(py_use_underline))
            gtk_label_set_text_with_mnemonic(GTK_LABEL(accel_label), text);
        else
            gtk_label_set_text(GTK_LABEL(accel_label), text);
        gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(accel_label),
                                         GTK_WIDGET(self->obj));
        gtk_widget_show(accel_label);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkCheckMenuItem object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_CHECK_MENU_ITEM
%%
override gtk_radio_menu_item_new kwargs
static int
_wrap_gtk_radio_menu_item_new(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "group", "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_group = Py_None;
    GtkRadioMenuItem *group;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OzO:GtkRadioMenuItem.__init__", kwlist,
                                     &py_group, &text, &py_use_underline))
        return -1;
    if (py_group == Py_None)
        group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioMenuItem_Type))
        group = GTK_RADIO_MENU_ITEM(pygobject_get(py_group));
    else {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkRadioMenuItem or None");
        return -1;
    }

    pygobject_construct(self, NULL);

    if (text) {
        GtkWidget *accel_label;
        accel_label = g_object_new(GTK_TYPE_ACCEL_LABEL, NULL);
        gtk_misc_set_alignment(GTK_MISC(accel_label), 0.0, 0.5);
        gtk_container_add(GTK_CONTAINER(self->obj), accel_label);
        if (PyObject_IsTrue(py_use_underline))
            gtk_label_set_text_with_mnemonic(GTK_LABEL(accel_label), text);
        else
            gtk_label_set_text(GTK_LABEL(accel_label), text);
        gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(accel_label),
                                         GTK_WIDGET(self->obj));
        gtk_widget_show(accel_label);
    }
    if (group)
        gtk_radio_menu_item_set_group(GTK_RADIO_MENU_ITEM(self->obj),
                                      gtk_radio_menu_item_get_group(group));
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkRadioMenuItem object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_RADIO_MENU_ITEM
%%
new-constructor GTK_TYPE_IMAGE_MENU_ITEM
%%
override gtk_image_menu_item_new kwargs
static int
_wrap_gtk_image_menu_item_new(PyGObject *self, PyObject *args,PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "accel_group", NULL };
    gchar *stock_id = NULL;
    PyObject *py_accel_group = Py_None;
    GtkAccelGroup *accel_group= NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zO:GtkImageMenuItem.__init__",kwlist,
                                     &stock_id, &py_accel_group))
        return -1;
    if (pygobject_check(py_accel_group, &PyGtkAccelGroup_Type))
        accel_group = GTK_ACCEL_GROUP(pygobject_get(py_accel_group));

    if (stock_id) {
        pygobject_construct(self,
                            "label", stock_id,
                            "use-stock", TRUE,
                            "accel-group", accel_group,
                            NULL);
    }
    else
        pygobject_construct(self, NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkImageMenuItem object");
        return -1;
    }
    return 0;
}
%%
override-slot GtkRequisition.tp_as_sequence
static Py_ssize_t
_wrap_gtk_requisition_length(PyGBoxed *self)
{
    return 2;
}
static PyObject *
_wrap_gtk_requisition_getitem(PyGBoxed *self, Py_ssize_t pos)
{
    GtkRequisition *requisition;

    if (pos < 0) pos += 2;
    if (pos < 0 || pos >= 2) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return NULL;
    }
    requisition = pyg_boxed_get(self, GtkRequisition);
    switch (pos) {
    case 0: return PyLong_FromLong(requisition->width);
    case 1: return PyLong_FromLong(requisition->height);
    default:
        g_assert_not_reached();
        return NULL;
    }
}
static int
_wrap_gtk_requisition_setitem(PyGBoxed *self, Py_ssize_t pos, PyObject *value)
{
    GtkRequisition *requisition;
    gint val;

    if (pos < 0) pos += 2;
    if (pos < 0 || pos >= 2) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return -1;
    }
    requisition = pyg_boxed_get(self, GtkRequisition);
    val = PyLong_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    switch(pos) {
    case 0: requisition->width      = val; break;
    case 1: requisition->height     = val; break;
    default:
        g_assert_not_reached();
        return -1;
    }
    return 0;
}
static PySequenceMethods _wrap_gtk_requisition_tp_as_sequence = {
    (lenfunc)_wrap_gtk_requisition_length,
    0,
    0,
    (ssizeargfunc)_wrap_gtk_requisition_getitem,
    0,
    (ssizeobjargproc)_wrap_gtk_requisition_setitem,
    0,
};
%%
override-attr GtkRequisition.width
static int
_wrap_gtk_requisition__set_width(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyLong_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GtkRequisition)->width = val;
    return 0;
}
%%
override-attr GtkRequisition.height
static int
_wrap_gtk_requisition__set_height(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyLong_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GtkRequisition)->height = val;
    return 0;
}
%%
override gtk_notebook_query_tab_label_packing kwargs
static PyObject *
_wrap_gtk_notebook_query_tab_label_packing(PyGObject *self, PyObject *args,
                                           PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    gboolean expand, fill;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkNotebook.query_tab_label_packing",
                                     kwlist, &child))
        return NULL;
    if (!pygobject_check(child, &PyGtkWidget_Type)) {
        PyErr_SetString(PyExc_TypeError, "child must be a GtkWidget");
        return NULL;
    }
    gtk_notebook_query_tab_label_packing(GTK_NOTEBOOK(self->obj),
                                         GTK_WIDGET(child->obj),
                                         &expand, &fill, &pack_type);
    return Py_BuildValue("(iiN)", expand, fill,
			 pyg_enum_from_gtype(GTK_TYPE_PACK_TYPE, pack_type));
}
%%
override gtk_list_insert_items kwargs
static PyObject *
_wrap_gtk_list_insert_items(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "items", "position", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int position, len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!i:GtkList.insert_items",
                                     kwlist, &PyList_Type, &py_items,
                                     &position))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_insert_items(GTK_LIST(self->obj), items, position);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_append_items kwargs
static PyObject *
_wrap_gtk_list_append_items(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.append_items",
                                     kwlist, &PyList_Type, &py_items))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_append_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_prepend_items kwargs
static PyObject *
_wrap_gtk_list_prepend_items(PyGObject *self, PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.preppend_items",
                                     kwlist, &PyList_Type, &py_items))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_prepend_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_remove_items kwargs
static PyObject *
_wrap_gtk_list_remove_items(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.remove_items",
                                     kwlist, &PyList_Type, &py_items))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_remove_items(GTK_LIST(self->obj), items);
    g_list_free(items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override-attr GtkList.selection
static PyObject *
_wrap_gtk_list__get_selection(PyGObject *self, void *closure)
{
    GList *selection;
    PyObject *item, *ret = PyList_New(0);

    if (ret == NULL)
        return NULL;

    for (selection = GTK_LIST(self->obj)->selection; selection != NULL;
         selection = selection->next) {
        item = pygobject_new((GObject *) GTK_LIST_ITEM(selection->data));

        if (!item) {
            Py_DECREF(ret);
            return NULL;
        }

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    return ret;
}
%%
override gtk_list_get_selection noargs
static PyObject *
_wrap_gtk_list__get_selection(PyGObject *self, void *closure);
static PyObject *
_wrap_gtk_list_get_selection(PyGObject *self)
{
    return _wrap_gtk_list__get_selection(self, NULL);
}
%%
override gtk_color_selection_get_current_color noargs
static PyObject *
_wrap_gtk_color_selection_get_current_color(PyGObject *self)
{
    GdkColor colour = { 0, };

    gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(self->obj),
                                          &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_color_selection_get_previous_color noargs
static PyObject *
_wrap_gtk_color_selection_get_previous_color(PyGObject *self)
{
    GdkColor colour = { 0, };

    gtk_color_selection_get_previous_color(GTK_COLOR_SELECTION(self->obj),
                                           &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_calendar_get_date noargs
static PyObject *
_wrap_gtk_calendar_get_date(PyGObject *self)
{
    guint year, month, day;

    gtk_calendar_get_date(GTK_CALENDAR(self->obj), &year, &month, &day);
    return Py_BuildValue("(iii)", year, month, day);
}
%%
override gtk_drag_dest_set kwargs
static PyObject *
_wrap_gtk_drag_dest_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flags", "targets", "actions", NULL };
    PyObject *py_flags, *py_targets, *py_actions;
    GtkDestDefaults flags;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOO:GtkWidget.drag_dest_set", kwlist,
                                     &py_flags, &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, py_flags, (gint *)&flags))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!PySequence_Check(py_targets)) {
        PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
        return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_GetItem(py_targets, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
            return NULL;
        }
    }
    gtk_drag_dest_set(GTK_WIDGET(self->obj), flags, targets, n_targets,
                      actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_dest_find_target kwargs
static PyObject *
_wrap_gtk_drag_dest_find_target(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "context", "target_list", NULL };
    PyObject *context, *py_targets;
    GtkTargetList *target_list;
    GdkAtom atom;
    gchar *name;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!O:GtkWidget.drag_dest_find_target",
                                     kwlist, &PyGdkDragContext_Type, &context,
                                     &py_targets))
        return NULL;

    if (!(target_list = pygtk_target_list_from_sequence(py_targets)))
        return NULL;

    atom = gtk_drag_dest_find_target(GTK_WIDGET(self->obj),
                                     GDK_DRAG_CONTEXT(pygobject_get(context)),
                                     target_list);
    gtk_target_list_unref(target_list);

    name = gdk_atom_name(atom);
    ret = PyUnicode_FromString(name);
    g_free(name);
    return ret;
}
%%
override gtk_drag_dest_get_target_list noargs
static PyObject *
_wrap_gtk_drag_dest_get_target_list(PyGObject *self)
{
    GtkTargetList *target_list;

    target_list = gtk_drag_dest_get_target_list(GTK_WIDGET(self->obj));

    if (!target_list) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return pygtk_target_list_to_list(target_list);
}
%%
override gtk_drag_dest_set_target_list kwargs
static PyObject *
_wrap_gtk_drag_dest_set_target_list(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "target_list", NULL };
    PyObject *py_targets;
    GtkTargetList *target_list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkWidget.drag_dest_set_target_list",
                                     kwlist, &py_targets))
        return NULL;

    if (!(target_list = pygtk_target_list_from_sequence(py_targets)))
        return NULL;

    gtk_drag_dest_set_target_list(GTK_WIDGET(self->obj), target_list);
    gtk_target_list_unref(target_list);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_source_set kwargs
static PyObject *
_wrap_gtk_drag_source_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_button_mask", "targets", "actions", NULL };
    PyObject *py_sbmask, *py_targets, *py_actions;
    GdkModifierType sbmask;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOO:GtkWidget.drag_source_set", kwlist,
                                     &py_sbmask, &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,
                             py_sbmask, (gint *)&sbmask))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    gtk_drag_source_set(GTK_WIDGET(self->obj), sbmask, targets, n_targets,
                        actions);
    g_free(targets);
    Py_DECREF(py_targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_begin kwargs
static PyObject *
_wrap_gtk_drag_begin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "actions", "button", "event", NULL };
    PyObject *py_targets, *py_actions, *event;
    GtkTargetList *targets;
    GdkDragAction actions;
    gint button;
    GdkDragContext *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOiO:GtkWidget.drag_begin", kwlist,
                                     &py_targets, &py_actions, &button,
                                     &event))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!pyg_boxed_check(event, GDK_TYPE_EVENT)) {
        PyErr_SetString(PyExc_TypeError, "event must be a GdkEvent");
        return NULL;
    }
    if (!(targets = pygtk_target_list_from_sequence(py_targets)))
        return NULL;

    context = gtk_drag_begin(GTK_WIDGET(self->obj), targets, actions, button,
                             pyg_boxed_get(event, GdkEvent));
    gtk_target_list_unref(targets);
    return pygobject_new((GObject *)context);
}
%%
override gtk_selection_add_targets kwargs
static PyObject *
_wrap_gtk_selection_add_targets(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "selection", "targets", NULL };
    PyObject *py_targets, *py_selection;
    GtkTargetEntry *targets;
    GdkAtom selection;
    int n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO:GtkWidget.selection_add_targets",
                                     kwlist, &py_selection, &py_targets))
        return NULL;
    selection = pygdk_atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
        return NULL;

    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    gtk_selection_add_targets(GTK_WIDGET(self->obj), selection,
                              targets, n_targets);
    g_free(targets);
    Py_DECREF(py_targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_child_anchor_get_widgets noargs
static PyObject *
_wrap_gtk_text_child_anchor_get_widgets(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *ret;

    list = gtk_text_child_anchor_get_widgets(GTK_TEXT_CHILD_ANCHOR(self->obj));

    ret = PyList_New(0);
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        GtkWidget *widget = tmp->data;
        PyObject *item = pygobject_new((GObject *)widget);

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    g_list_free(list);
    return ret;
}
%%
override gtk_dialog_new_with_buttons kwargs
static int
_wrap_gtk_dialog_new_with_buttons(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    gchar *title = NULL;
    PyGObject *py_window = NULL;
    PyObject *py_flags = NULL, *py_buttons = Py_None;
    GtkDialogFlags flags = 0;
    int len, i;
    GtkWindow *parent;
    
    static char *kwlist[] = { "title", "parent", "flags", "buttons", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zOOO:GtkDialog.__init__", kwlist,
                                     &title, &py_window, &py_flags,
                                     &py_buttons))
        return -1;

    if (py_window == NULL || (PyObject*)py_window == Py_None)
	parent = NULL;
    else if (pygobject_check(py_window, &PyGtkWindow_Type))
	parent = GTK_WINDOW(py_window->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "parent must be a GtkWindow or None");
        return -1;
    }

    if (pyg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, py_flags, (gint *)&flags))
        return -1;
    if (py_buttons == Py_None)
        len = 0;
    else if (PyTuple_Check(py_buttons))
        len = PyTuple_Size(py_buttons);
    else {
        PyErr_SetString(PyExc_TypeError, "buttons must be a tuple containing text/response pairs or None");
        return -1;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }

    if (pygobject_constructv(self, 0, NULL)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkDialog object");
        return -1;
    }

  if (title)
    gtk_window_set_title (GTK_WINDOW (self->obj), title);

  if (parent)
    gtk_window_set_transient_for (GTK_WINDOW (self->obj), parent);

  if (flags & GTK_DIALOG_MODAL)
    gtk_window_set_modal (GTK_WINDOW (self->obj), TRUE);
  
  if (flags & GTK_DIALOG_DESTROY_WITH_PARENT)
    gtk_window_set_destroy_with_parent (GTK_WINDOW (self->obj), TRUE);

  if (flags & GTK_DIALOG_NO_SEPARATOR)
    gtk_dialog_set_has_separator (GTK_DIALOG (self->obj), FALSE);
    
    for (i = 0; i < len; i += 2) {
        PyObject *text = PyTuple_GetItem(py_buttons, i);
        PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
        if (!PyUnicode_Check(text)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each text/response id pair "
                            "must be a string");
            return -1;
        }
        if (!PyLong_Check(id)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each text/response id pair "
                            "must be a number");
            return -1;
        }
        gtk_dialog_add_button(GTK_DIALOG(self->obj), PyUnicode_AsUTF8(text),
                              PyLong_AsLong(id));
    }
    
    return 0;
}
%%
new-constructor GTK_TYPE_DIALOG
%%
override gtk_dialog_run noargs
static PyObject *
_wrap_gtk_dialog_run(PyGObject *self)
{
    gint retval;

    pyg_begin_allow_threads;
    retval = gtk_dialog_run(GTK_DIALOG(self->obj));
    pyg_end_allow_threads;
    return PyLong_FromLong(retval);
}
%%
override gtk_dialog_add_buttons
static PyObject *
_wrap_gtk_dialog_add_buttons(PyGObject *self, PyObject *args)
{
    GtkDialog *dialog;
    int i, len;

    dialog = GTK_DIALOG(self->obj);

    len = PyTuple_Size(args);
    if (len % 2 != 0) {
	PyErr_SetString(PyExc_TypeError,
			"must pass an even number of arguments");
	return NULL;
    }
    
    for (i = 0; i < len; i+= 2) {
	PyObject *curr_args = PyTuple_GetSlice(args, i, i + 2);
	gchar *text;
	gint response_id;
	
	if (!PyArg_ParseTuple(curr_args, "si", &text, &response_id))
	    return NULL;
	
	gtk_dialog_add_button(dialog, text, response_id);
    }
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
init
#if GTK_CHECK_VERSION(2, 9, 0)
    pyg_set_object_has_new_constructor(GTK_TYPE_MESSAGE_DIALOG);
#endif
%%
override gtk_message_dialog_new kwargs
static int
_wrap_gtk_message_dialog_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkButtonsType buttons = GTK_BUTTONS_NONE;
    static char *kwlist[] = { "parent", "flags", "type", "buttons", "message_format", NULL };
    PyObject *py_flags = NULL, *py_type = NULL, *py_buttons = NULL;
    GtkDialogFlags flags = 0;
    GtkWindow *parent = NULL;
    GtkMessageType type = GTK_MESSAGE_INFO;
    PyGObject *py_parent = NULL;
    char *message_format = NULL;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOOOz:GtkMessageDialog.__init__", kwlist, &py_parent, &py_flags, &py_type, &py_buttons, &message_format))
        return -1;
    if ((PyObject *)py_parent == Py_None)
        parent = NULL;
    else if (py_parent && pygobject_check(py_parent, &PyGtkWindow_Type))
        parent = GTK_WINDOW(py_parent->obj);
    else if (py_parent) {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkWindow or None");
        return -1;
    }
    if (pyg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, py_flags, (gint *)&flags))
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_MESSAGE_TYPE, py_type, (gint *)&type))
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_BUTTONS_TYPE, py_buttons, (gint *)&buttons))
        return -1;

#if GTK_CHECK_VERSION(2, 9, 0)

    if (flags & GTK_DIALOG_NO_SEPARATOR)
        g_warning("The gtk.DIALOG_NO_SEPARATOR flag cannot be used for gtk.MessageDialog");
    
    pygobject_construct(self, "buttons", buttons,
                        "message-type", type,
                        (message_format? "text" : NULL), message_format,
                        NULL);
    if (parent != NULL)
        gtk_window_set_transient_for(GTK_WINDOW(self->obj), parent);
    
    if (flags & GTK_DIALOG_MODAL)
        gtk_window_set_modal(GTK_WINDOW(self->obj), TRUE);

    if (flags & GTK_DIALOG_DESTROY_WITH_PARENT)
        gtk_window_set_destroy_with_parent(GTK_WINDOW(self->obj), TRUE);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkMessageDialog object");
        return -1;
    }
    
    g_object_ref(self->obj); /* we don't own the first reference of windows */

#else

      /* Note: with older API (< 2.10), it is impossible to
       * construct a GtkMessageDialog through g_object_new(), because
       * there is no 'message' property and the label field is
       * private */
    if (message_format)
        self->obj = (GObject *)gtk_message_dialog_new(parent, flags, type,
                                                      buttons, "%s",
                                                      message_format);
    else
        self->obj = (GObject *)gtk_message_dialog_new(parent, flags, type,
                                                      buttons, message_format);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkMessageDialog object");
        return -1;
    }
    
    g_object_ref(self->obj); /* we don't own the first reference of windows */

    if (pyg_type_from_object((PyObject *) self) != GTK_TYPE_MESSAGE_DIALOG) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing gtk.MessageDialog");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);

#endif
    return 0;
}
%%
override gtk_progress_bar_new_with_adjustment kwargs
static int
_wrap_gtk_progress_bar_new_with_adjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkAdjustment *adjustment = NULL;
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkProgressBar.__init__", kwlist, &py_adjustment))
        return -1;
    if ((PyObject *)py_adjustment == Py_None)
        adjustment = NULL;
    else if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if (py_adjustment) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
	return -1;
    }


    if (adjustment)
        pygobject_construct(self, "adjustment", adjustment, NULL);
    else
        pygobject_construct(self, NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkProgressBar object");
	return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_PROGRESS_BAR
%%
override gtk_rc_set_default_files kwargs
static PyObject *
_wrap_gtk_rc_set_default_files(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    gchar **filenames = NULL;
    static char *kwlist[] = { "filenames", NULL };
    PyObject *py_filenames = NULL;
    int i, n_files;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:rc_set_default_files",
                                     kwlist, &py_filenames))
        return NULL;

    if (!PySequence_Check(py_filenames)) {
        PyErr_SetString(PyExc_TypeError, "filenames must be a sequence");
        return NULL;
    }

    n_files = PySequence_Length(py_filenames);
    filenames = g_new(gchar *, n_files + 1);
    for (i = 0; i < n_files; i++) {
        PyObject *item = PySequence_GetItem(py_filenames, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        filenames[i] = PyUnicode_AsUTF8(item);
    }
    filenames[n_files] = NULL;

    gtk_rc_set_default_files(filenames);

    g_free(filenames);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_rc_get_default_files noargs
static PyObject *
_wrap_gtk_rc_get_default_files(PyGObject *self)
{
    gchar **filenames = NULL, **tmp;
    int i = 0, j;
    PyObject *ret;

    filenames = gtk_rc_get_default_files();

    tmp = filenames;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyUnicode_FromString(filenames[j]));

    return ret;
}
%%
override gtk_icon_set_new_from_pixbuf kwargs
static int
_wrap_gtk_icon_set_new_from_pixbuf(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *pixbuf = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkIconSet.__init__", kwlist, &pixbuf))
        return -1;
    if (pixbuf && !pygobject_check(pixbuf, &PyGdkPixbuf_Type)) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf");
        return -1;
    }
    self->gtype = GTK_TYPE_ICON_SET;
    self->free_on_dealloc = FALSE;
    if (pixbuf)
        self->boxed = gtk_icon_set_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj));
    else
        self->boxed = gtk_icon_set_new();

    if (!self->boxed) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkIconSet object");
        return -1;
    }
    self->free_on_dealloc = TRUE;
    return 0;
}
%%
override gtk_icon_set_get_sizes noargs
static PyObject *
_wrap_gtk_icon_set_get_sizes(PyGObject *self)
{
    GtkIconSize *sizes;
    int i, n_sizes;
    PyObject *ret;

    gtk_icon_set_get_sizes(pyg_boxed_get(self, GtkIconSet), &sizes, &n_sizes);

    ret = PyTuple_New(n_sizes);
    for (i = 0; i < n_sizes; i++)
        PyTuple_SetItem(ret, i, PyLong_FromLong(sizes[i]));
    g_free(sizes);

    return ret;
}
%%
override gtk_stock_add kwargs
static PyObject *
_wrap_gtk_stock_add(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    PyObject *py_item;
    GtkStockItem *items = NULL;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:stock_add", kwlist,
                                     &py_items))
        return NULL;

    if (!PySequence_Check(py_items)) {
        PyErr_SetString(PyExc_TypeError,
                        "items must be a sequence of five-element tuples");
        return NULL;
    }

    len = PySequence_Length(py_items);
    if (len > 0) {
        items = g_new(GtkStockItem, len);
        for (i = 0; i < len; i++) {
            py_item = PySequence_GetItem(py_items, i);
            if (!py_item) goto error;
            if (!PyArg_ParseTuple(py_item, "zziiz",
                                  &items[i].stock_id, &items[i].label,
                                  &items[i].modifier, &items[i].keyval,
                                  &items[i].translation_domain)) {
                PyErr_Clear();
                PyErr_SetString(PyExc_TypeError, "items sequence members "
                                "must be of form (stock_id, label, modifiers, "
                                "keyval, domain)");
                goto error;
            }
	    Py_DECREF(py_item);
        }
        gtk_stock_add(items, PySequence_Length(py_items));
        g_free(items);
    }
    Py_INCREF(Py_None);
    return Py_None;
 error:
    g_free(items);
    return NULL;
}
%%
override gtk_stock_list_ids noargs
static PyObject *
_wrap_gtk_stock_list_ids(PyGObject *self)
{
    GSList *ids;
    PyObject *list;
    int i = 0;

    ids = gtk_stock_list_ids();

    list = PyList_New(g_slist_length(ids));
    for (; ids; ids = ids->next, i++) {
        PyList_SetItem(list, i, PyUnicode_FromString(ids->data));
        g_free(ids->data);
    }
    g_slist_free(ids);

    return list;
}
%%
override gtk_stock_lookup args
static PyObject *
_wrap_gtk_stock_lookup(PyGObject *self, PyObject *args)
{
    gchar *stock_id;
    GtkStockItem item;

    if (!PyArg_ParseTuple(args, "s:gtk.stock_lookup",
                          &stock_id)) {
        return NULL;
    }

    if(gtk_stock_lookup(stock_id, &item)) {
        return Py_BuildValue("zzNiz",
                             item.stock_id,
                             item.label,
                             pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE,
                                                  item.modifier),
                             item.keyval,
                             item.translation_domain);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_layout_get_size noargs
static PyObject *
_wrap_gtk_layout_get_size(PyGObject *self)
{
    guint width, height;
    gtk_layout_get_size(GTK_LAYOUT(self->obj), &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_frame_get_label_align noargs
static PyObject *
_wrap_gtk_frame_get_label_align(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_frame_get_label_align(GTK_FRAME(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
%%
override gtk_misc_get_alignment noargs
static PyObject *
_wrap_gtk_misc_get_alignment(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_misc_get_alignment(GTK_MISC(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
%%
override gtk_misc_get_padding noargs
static PyObject *
_wrap_gtk_misc_get_padding(PyGObject *self)
{
    gint xpad, ypad;

    gtk_misc_get_padding(GTK_MISC(self->obj), &xpad, &ypad);
    return Py_BuildValue("(ii)", xpad, ypad);
}
%%
override gtk_ruler_get_range noargs
static PyObject *
_wrap_gtk_ruler_get_range(PyGObject *self)
{
    gdouble lower, upper, position, max_size;

    gtk_ruler_get_range(GTK_RULER(self->obj), &lower, &upper, &position,
                        &max_size);
    return Py_BuildValue("(dddd)", lower, upper, position, max_size);
}
%%
override gtk_im_context_get_preedit_string noargs
static PyObject *
_wrap_gtk_im_context_get_preedit_string(PyGObject *self)
{
    gchar *str;
    PangoAttrList *attrs;
    gint cursor_pos;
    PyObject *ret;

    gtk_im_context_get_preedit_string(GTK_IM_CONTEXT(self->obj),
                                      &str, &attrs, &cursor_pos);

    ret = Py_BuildValue("(sNi)", str,
                        pyg_boxed_new(PANGO_TYPE_ATTR_LIST, attrs, FALSE,TRUE),
                        cursor_pos);
    g_free(str);

    return ret;
}
%%
override gtk_im_context_filter_keypress kwargs
static PyObject *
_wrap_gtk_im_context_filter_keypress(PyGObject *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    PyObject *key;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkIMContext.filter_keypress", kwlist,
                                     &key))
        return NULL;

    if (!pyg_boxed_check(key, GDK_TYPE_EVENT)) {
        PyErr_SetString(PyExc_TypeError, "key must be a GdkEvent");
        return NULL;
    }

    ret = gtk_im_context_filter_keypress(GTK_IM_CONTEXT(self->obj),
                                         pyg_boxed_get(key, GdkEventKey));
    return PyBool_FromLong(ret);
}
%%
override gtk_im_context_get_surrounding noargs
static PyObject *
_wrap_gtk_im_context_get_surrounding(PyGObject *self)
{
    gchar *text;
    gint cursor_index;

    if (gtk_im_context_get_surrounding(GTK_IM_CONTEXT(self->obj),
                                       &text, &cursor_index)) {
        PyObject *ret = Py_BuildValue("(si)", text, cursor_index);

        g_free(text);
        return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override-attr GtkTooltips.active_tips_data
static PyObject *
_wrap_gtk_tooltips__get_active_tips_data(PyGObject *self, void *closure)
{
    GtkTooltips *tips = GTK_TOOLTIPS(self->obj);
    GtkTooltipsData *data = tips->active_tips_data;

    if (data == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return Py_BuildValue("NNss",
                         pygobject_new((GObject *)data->tooltips),
                         pygobject_new((GObject *)data->widget),
                         data->tip_text,
                         data->tip_private);
}
%%
override-attr GtkTooltips.tips_data_list
static PyObject *
_wrap_gtk_tooltips__get_tips_data_list(PyGObject *self, void *closure)
{
    return PyList_New(0);
}
%%
override-attr GtkAdjustment.value
static int
_wrap_gtk_adjustment__set_value(PyGObject *self, PyObject *value,
                                void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->value, "value"))
        return -1;
    gtk_adjustment_value_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.lower
static int
_wrap_gtk_adjustment__set_lower(PyGObject *self, PyObject *value,
                                void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->lower, "lower"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.upper
static int
_wrap_gtk_adjustment__set_upper(PyGObject *self, PyObject *value,
                                void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->upper, "upper"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.step_increment
static int
_wrap_gtk_adjustment__set_step_increment(PyGObject *self, PyObject *value,
                                         void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->step_increment,
                                       "step_increment"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.page_increment
static int
_wrap_gtk_adjustment__set_page_increment(PyGObject *self, PyObject *value,
                                         void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->page_increment,
                                       "page_increment"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.page_size
static int
_wrap_gtk_adjustment__set_page_size(PyGObject *self, PyObject *value,
                                         void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->page_size, "page_size"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override gtk_adjustment_set_all kwargs
static PyObject *
_wrap_gtk_adjustment_set_all(PyGObject *self,
			     PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "value", "lower", "upper", "step_increment",
			      "page_increment", "page_size", NULL };
    GtkAdjustment *adj = GTK_ADJUSTMENT(self->obj);
    double *value = &adj->value, *lower = &adj->lower, *upper = &adj->upper;
    double *step_increment = &adj->step_increment;
    double *page_increment = &adj->page_increment;
    double *page_size = &adj->page_size;
    double old_value = *value, old_lower = *lower, old_upper = *upper;
    double old_step_increment = *step_increment;
    double old_page_increment = *page_increment;
    double old_page_size = *page_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|dddddd:gtk_adjustment_set_all",
				     kwlist,
				     value, lower, upper, step_increment,
				     page_increment, page_size)) {
        adj->value = old_value;
        adj->lower = old_lower;
        adj->upper = old_upper;
        adj->step_increment = old_step_increment;
        adj->page_increment = old_page_increment;
        adj->page_size = old_page_size;
        return NULL;
    }
    
    if (adj->value != old_value)
        gtk_adjustment_value_changed(adj);
    if (adj->lower != old_lower || adj->upper != old_upper
	|| adj->step_increment != old_step_increment
	|| adj->page_increment != old_page_increment
	|| adj->page_size != old_page_size)
        gtk_adjustment_changed(adj);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_file_selection_get_selections noargs
static PyObject *
_wrap_gtk_file_selection_get_selections(PyGObject *self)
{
    gchar **filenames = NULL;
    int size;
    int i;
    PyObject *ret;

    filenames = gtk_file_selection_get_selections(
        GTK_FILE_SELECTION(self->obj));

    for (i = 0; filenames[i]; i++);
    size = i;

    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
        PyTuple_SetItem(ret, i, PyUnicode_FromString(filenames[i]));

    return ret;
}
%%
override gtk_icon_size_lookup kwargs
static PyObject *
_wrap_gtk_icon_size_lookup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_size", NULL };
    PyObject *py_icon_size;
    GtkIconSize icon_size;
    gint width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:icon_size_lookup",
                                     kwlist, &py_icon_size))
        return NULL;

    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_icon_size,
                           (gint *) &icon_size))
        return NULL;

    gtk_icon_size_lookup(icon_size, &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_image_get_pixmap noargs
static PyObject *
_wrap_gtk_image_get_pixmap(PyGObject *self)
{
    GdkPixmap *pixmap;
    GdkBitmap *mask;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_PIXMAP || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkPixmap or empty");
        return NULL;
    }
    gtk_image_get_pixmap(GTK_IMAGE(self->obj), &pixmap, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_image_get_image noargs
static PyObject *
_wrap_gtk_image_get_image(PyGObject *self)
{
    GdkImage *image;
    GdkBitmap *mask;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_IMAGE || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkImage or empty");
        return NULL;
    }
    gtk_image_get_image(GTK_IMAGE(self->obj), &image, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)image),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_image_get_stock noargs
static PyObject *
_wrap_gtk_image_get_stock(PyGObject *self)
{
    gchar *stock_id;
    GtkIconSize size;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_STOCK || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a stock icon or empty");
        return NULL;
    }
    gtk_image_get_stock(GTK_IMAGE(self->obj), &stock_id, &size);

    if (stock_id) {
	return Py_BuildValue("(NN)",
			     PyUnicode_FromString(stock_id),
			     pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size));
    } else {
	Py_INCREF(Py_None);
	return Py_BuildValue("(ON)",
			     Py_None,
			     pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size));
    }
}
%%
override gtk_image_get_icon_set noargs
static PyObject *
_wrap_gtk_image_get_icon_set(PyGObject *self)
{
    GtkIconSet *icon_set;
    GtkIconSize size;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_ICON_SET || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GtkIconSet or empty");
        return NULL;
    }
    gtk_image_get_icon_set(GTK_IMAGE(self->obj), &icon_set, &size);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)icon_set),
			 pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size));
}
%%
override gtk_image_get noargs
static PyObject *
_wrap_gtk_image_get(PyGObject *self)
{
    return _wrap_gtk_image_get_image(self);
}
%%
override gtk_image_get_pixbuf noargs
static PyObject *
_wrap_gtk_image_get_pixbuf(PyGObject *self)
{
    GdkPixbuf *ret;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_PIXBUF || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkPixbuf or empty");
        return NULL;
    }
    ret = gtk_image_get_pixbuf(GTK_IMAGE(self->obj));
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
%%
override gtk_image_get_animation noargs
static PyObject *
_wrap_gtk_image_get_animation(PyGObject *self)
{
    GdkPixbufAnimation *ret;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_ANIMATION || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkPixbufAnimation or empty");
        return NULL;
    }

    ret = gtk_image_get_animation(GTK_IMAGE(self->obj));
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
%%
override gtk_radio_button_set_group kwargs
static PyObject *
_wrap_gtk_radio_button_set_group(PyGObject *self, PyObject *args,
				 PyObject *kwargs) {
    static char *kwlist[] = { "group", NULL };
    PyObject *py_group;
    GSList *list;
    GtkRadioButton *group;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"O:GtkRadioButton.set_group",
                                     kwlist, &py_group))
        return NULL;

    if (pygobject_check(py_group, &PyGtkRadioButton_Type)) {
	group = GTK_RADIO_BUTTON(pygobject_get(py_group));
	list = gtk_radio_button_get_group(group);
	if (list == gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj))) {
	    PyErr_SetString(PyExc_ValueError, "radio button already in group");
	    return NULL;
	}
    } else if (py_group == Py_None) {
	list = NULL;
    } else {
	PyErr_SetString(PyExc_TypeError, "group must be a RadioGroup or None");
	return NULL;
    }

    gtk_radio_button_set_group(GTK_RADIO_BUTTON(self->obj), list);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_radio_menu_item_get_group noargs
static PyObject *
_wrap_gtk_radio_menu_item_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
%%
override gtk_radio_menu_item_set_group kwargs
static PyObject *
_wrap_gtk_radio_menu_item_set_group(PyGObject *self, PyObject *args,
				    PyObject *kwargs) {
    static char *kwlist[] = { "group", NULL };
    PyObject *py_group;
    GSList *list;
    GtkRadioMenuItem *group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkRadioMenuItem.set_group",
                                     kwlist, &py_group))
        return NULL;
    
    if (pygobject_check(py_group, &PyGtkRadioMenuItem_Type)) {
	group = GTK_RADIO_MENU_ITEM(pygobject_get(py_group));
	list = gtk_radio_menu_item_get_group(group);
	if (list == gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(self->obj))) {
	    PyErr_SetString(PyExc_ValueError, "radio menu item already in group");
	    return NULL;
	}
    } else if (py_group == Py_None) {
	list = NULL;
    } else {
	PyErr_SetString(PyExc_TypeError, "group must be a RadioMenuItem or None");
	return NULL;
    }

    gtk_radio_menu_item_set_group(GTK_RADIO_MENU_ITEM(self->obj), list);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_scrolled_window_get_policy  noargs
static PyObject *
_wrap_gtk_scrolled_window_get_policy(PyGObject *self)
{
    GtkPolicyType hscrollbar_policy, vscrollbar_policy;

    gtk_scrolled_window_get_policy(GTK_SCROLLED_WINDOW(self->obj),
				   &hscrollbar_policy, &vscrollbar_policy);
    return Py_BuildValue("(NN)",
			 pyg_enum_from_gtype(GTK_TYPE_POLICY_TYPE, hscrollbar_policy),
			 pyg_enum_from_gtype(GTK_TYPE_POLICY_TYPE, vscrollbar_policy));
}
%%
override gtk_tooltips_data_get kwargs
static PyObject *
_wrap_gtk_tooltips_data_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;
    GtkTooltipsData *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkTooltips.data_get",
				     kwlist, &PyGtkWidget_Type, &widget))
        return NULL;

    data = gtk_tooltips_data_get(GTK_WIDGET(widget->obj));

    if (!data) {
	Py_INCREF(Py_None);
	return Py_None;
    }

    return Py_BuildValue("NNss",
			 pygobject_new((GObject *)data->tooltips),
			 pygobject_new((GObject *)data->widget),
			 data->tip_text,
			 data->tip_private);
}
%%
override gtk_tooltips_data_get1 kwargs
static PyObject *
_wrap_gtk_tooltips_data_get1(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use tooltips_data_get") < 0)
        return NULL;

    return _wrap_gtk_tooltips_data_get(self, args, kwargs);
}
%%
override gtk_accelerator_parse kwargs
static PyObject *
_wrap_gtk_accelerator_parse(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accelerator", NULL };
    gchar *accel;
    guint keyval;
    GdkModifierType modifier;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:Gtk.accelerator_parse",
				     kwlist, &accel))
        return NULL;

    gtk_accelerator_parse((const gchar *)accel, &keyval, &modifier);

    return Py_BuildValue("iN", keyval,
                         pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE,
                                              modifier));
}
%%
override gtk_accel_map_lookup_entry kwargs
static PyObject *
_wrap_gtk_accel_map_lookup_entry(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", NULL };
    gchar *accel_path;
    GtkAccelKey accel_key;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:gtk.accel_map_lookup_entry",
				     kwlist, &accel_path))
        return NULL;

    if (gtk_accel_map_lookup_entry((const gchar *)accel_path, &accel_key))
	return Py_BuildValue("iN", accel_key.accel_key,
			     pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE, accel_key.accel_mods));

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_accel_map_load_fd kwargs
static PyObject *
_wrap_gtk_accel_map_load_fd(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "fd", NULL };
    gint fd;
    PyObject *py_fd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.accel_map_load_fd",
				     kwlist, &py_fd))
        return NULL;

    if ((fd = PyObject_AsFileDescriptor(py_fd)) != -1)
	gtk_accel_map_load_fd(fd);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_accel_map_save_fd kwargs
static PyObject *
_wrap_gtk_accel_map_save_fd(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "fd", NULL };
    gint fd;
    PyObject *py_fd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.accel_map_save_fd",
				     kwlist, &py_fd))
        return NULL;

    if ((fd = PyObject_AsFileDescriptor(py_fd)) != -1)
	gtk_accel_map_save_fd(fd);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_color_selection_palette_from_string kwargs
static PyObject *
_wrap_gtk_color_selection_palette_from_string(PyGObject *self, PyObject *args,
					      PyObject *kwargs)
{
    static char *kwlist[] = { "str", NULL };
    gchar *str;
    GdkColor *colors;
    gint i, n_colors;
    PyObject *py_list;

    if (!PyArg_ParseTupleAndKeywords(
	args, kwargs, "s:gtk.color_selection_palette_from_string",
	kwlist, &str))
        return NULL;

    if (!gtk_color_selection_palette_from_string(str, &colors, &n_colors)) {
	Py_INCREF(Py_None);
	return Py_None;
    }

    if ((py_list = PyList_New(n_colors)) == NULL) {
	g_free(colors);
	return NULL;
    }

    for (i = 0; i < n_colors; i++) {
	PyObject *item = pyg_boxed_new(GDK_TYPE_COLOR, &colors[i], TRUE, TRUE);

	PyList_SetItem(py_list, i, item);
    }
    g_free(colors);

    return py_list;
}
%%
override gtk_color_selection_palette_to_string kwargs
static PyObject *
_wrap_gtk_color_selection_palette_to_string(PyGObject *self, PyObject *args,
					      PyObject *kwargs)
{
    static char *kwlist[] = { "colors", NULL };
    gchar *str;
    GdkColor *colors;
    gint i, n_colors;
    PyObject *py_colors, *ret;

    if (!PyArg_ParseTupleAndKeywords(
	args, kwargs, "O:gtk.color_selection_palette_to_string",
	kwlist, &py_colors))
        return NULL;

    if (!(py_colors = PySequence_Fast(
              py_colors, "colors must be a sequence of gtk.gdk.Colors")))
        return NULL;

    n_colors = PySequence_Fast_GET_SIZE(py_colors);
    if ((colors = g_new0(GdkColor, n_colors)) == NULL) {
        Py_DECREF(py_colors);
	return NULL;
    }
    for (i = 0; i < n_colors; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_colors, i);
	if (!pyg_boxed_check(item, GDK_TYPE_COLOR)) {
	    PyErr_SetString(PyExc_TypeError,
			    "colors must contain gtk.gdk.Colors");
	    g_free(colors);
            Py_DECREF(py_colors);
	    return NULL;
	}
	colors[i] = *pyg_boxed_get(item, GdkColor);
    }

    str = gtk_color_selection_palette_to_string(colors, n_colors);
    ret = PyUnicode_FromString(str);
    g_free(colors);
    g_free(str);
    Py_DECREF(py_colors);

    return ret;
}

%%
override gtk_binding_entry_remove kwargs
static PyObject *
_wrap_gtk_binding_entry_remove(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "class_type", "keyval", "modifiers", NULL };
    int keyval;
    PyObject *py_modifiers = NULL;
    GdkModifierType modifiers;
    PyObject *class;
    GType class_type;
    GtkBindingSet *bset = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:gtk_binding_entry_remove",
				     kwlist, &class, &keyval, &py_modifiers))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_modifiers, (gint *)&modifiers))
        return NULL;

    class_type = pyg_type_from_object(class);
    if (class_type == 0)
        return NULL;

    bset = gtk_binding_set_by_class(gtk_type_class(class_type));
    gtk_binding_entry_remove(bset, keyval, modifiers);
    Py_INCREF(Py_None);
    return Py_None;
}

%%
define GtkAccelGroup.connect_group kwargs
static PyObject *
_wrap_gtk_accel_group_connect_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_key", "accel_mods", "accel_flags", "callback", NULL };
    int accel_key;
    PyObject *py_accel_mods = NULL, *py_accel_flags = NULL, *py_callback;
    GdkModifierType accel_mods;
    GtkAccelFlags accel_flags;
    GClosure *closure;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iOOO:GtkAccelGroup.connect", kwlist,
				     &accel_key, &py_accel_mods, &py_accel_flags,
				     &py_callback))
        return NULL;
    if (!PyCallable_Check(py_callback)) {
	PyErr_SetString(PyExc_TypeError, "callback argument not callable");
	return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accel_mods, (gint *)&accel_mods))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_ACCEL_FLAGS, py_accel_flags, (gint *)&accel_flags))
        return NULL;
    closure = pyg_closure_new(py_callback, NULL, NULL);
    pygobject_watch_closure((PyObject *)self, closure);
    gtk_accel_group_connect(GTK_ACCEL_GROUP(self->obj), accel_key,
			    accel_mods, accel_flags, closure);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_file_chooser_dialog_new kwargs
static int
_wrap_gtk_file_chooser_dialog_new(PyGObject *self,
				  PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "title", "parent", "action", "buttons", "backend", NULL };
    gchar *title = NULL;
    PyGObject *py_window = NULL;
    PyObject *py_buttons = Py_None;
    PyObject *py_action = NULL;
    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
    GtkWindow *parent = NULL;
    gchar *backend = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zOOOz:GtkFileChooserDialog.__init__", kwlist,
                                     &title, &py_window, &py_action,
                                     &py_buttons,
				     &backend))
        return -1;

    if (py_window == NULL || (PyObject*)py_window == Py_None)
	parent = NULL;
    else if (pygobject_check(py_window, &PyGtkWindow_Type))
	parent = GTK_WINDOW(py_window->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "parent must be a GtkWindow or None");
        return -1;
    }

    if (pyg_enum_get_value(GTK_TYPE_FILE_CHOOSER_ACTION, py_action,
                           (gint *)&action))
        return -1;
    if (py_buttons == Py_None)
        len = 0;
    else if (PyTuple_Check(py_buttons))
        len = PyTuple_Size(py_buttons);
    else {
        PyErr_SetString(PyExc_TypeError, "buttons must be a tuple containing text/response pairs or None");
        return -1;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }

    pygobject_construct(self,
                        "title", title, 
                        "action", action,
                        "file-system-backend", backend,
                        NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkFileChooserDialog object");
        return -1;
    }

  if (parent)
    gtk_window_set_transient_for (GTK_WINDOW (self->obj), parent);

  for (i = 0; i < len; i += 2) {
        PyObject *text = PyTuple_GetItem(py_buttons, i);
        PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
        if (!PyUnicode_Check(text)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each text/response id pair "
                            "must be a string");
            return -1;
        }
        if (!PyLong_Check(id)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each text/response id pair "
                            "must be a number");
            return -1;
        }
        gtk_dialog_add_button(GTK_DIALOG(self->obj), PyUnicode_AsUTF8(text),
                              PyLong_AsLong(id));
    }
    g_object_ref(self->obj); /* we don't own the first reference of windows */
    
    return 0;
}
%%
new-constructor GTK_TYPE_FILE_CHOOSER_DIALOG
%%
override gtk_ui_manager_get_action_groups noargs
static PyObject *
_wrap_gtk_ui_manager_get_action_groups(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *ret;

    list = gtk_ui_manager_get_action_groups(GTK_UI_MANAGER(self->obj));
    
    ret = PyList_New(0);
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        PyObject *item = pygobject_new(G_OBJECT(tmp->data));

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    
    return ret;
}
%%
override gtk_ui_manager_get_toplevels kwargs
static PyObject *
_wrap_gtk_ui_manager_get_toplevels(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "types", NULL };
    GtkUIManagerItemType types;
    PyObject *py_types = NULL;
    GSList *list, *tmp;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkUIManager.get_toplevels", kwlist,
				     &py_types))
        return NULL;
    
    if (pyg_flags_get_value(GTK_TYPE_UI_MANAGER_ITEM_TYPE, py_types, (gint *)&types))
        return NULL;

    list = gtk_ui_manager_get_toplevels(GTK_UI_MANAGER(self->obj), types);
    
    ret = PyList_New(0);
    for (tmp = list; tmp; tmp = tmp->next) {
        PyObject *item = pygobject_new(G_OBJECT(tmp->data));

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    
    return ret;
}
%%
override gtk_action_group_add_actions kwargs
static PyObject *
_wrap_gtk_action_group_add_actions (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "user_data", NULL };
    PyGILState_STATE state;
    PyObject *entries, *extra_args = NULL;
    int len, i;
    PyObject *item;
    GtkActionEntry entry;
    GtkAction *action;
    PyObject *callback, *py_action;
    GClosure *closure;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:GtkActionGroup.add_actions",
				     kwlist, &entries, &extra_args))
        return NULL;
    
    if (!PySequence_Check(entries)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    state = pyg_gil_state_ensure();
    
    len = PySequence_Size(entries);
    for (i = 0; i < len; i++) {
	item = PySequence_GetItem(entries, i);
        Py_DECREF(item);

        memset(&entry, 0, sizeof(entry));
        callback = Py_None;
	
        if (!PyArg_ParseTuple(item, "s|zzzzO", &(entry.name), &(entry.stock_id),
			      &(entry.label), &(entry.accelerator), &(entry.tooltip),
			      &callback)) {
            return NULL;
        }

	action = gtk_action_new(entry.name, entry.label, entry.tooltip,
				entry.stock_id);
	if (action == NULL) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GtkAction object");
	    return NULL;
	}
	    
	py_action = pygobject_new((GObject *)action);
	if (callback != Py_None) {
	    if (PyCallable_Check(callback)) {
		closure = pyg_closure_new(callback, extra_args, NULL);
		g_signal_connect_closure(action, "activate", closure, FALSE);
		pygobject_watch_closure(py_action, closure);
	    } else {
		PyErr_SetString(PyExc_TypeError,
				"One or more entry is missing a callback type");
		g_object_unref (action);
		Py_DECREF (py_action);
		return NULL;
	    }
	}
	
	gtk_action_group_add_action_with_accel (GTK_ACTION_GROUP(self->obj),
						GTK_ACTION(action),
						entry.accelerator);
	
	g_object_unref(action);
	Py_DECREF (py_action);
    }

    pyg_gil_state_release(state);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_action_group_add_toggle_actions kwargs
static PyObject *
_wrap_gtk_action_group_add_toggle_actions (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "user_data", NULL };
    PyGILState_STATE state;
    PyObject *entries, *extra_args = NULL;
    int len, i;
    PyObject *item;
    GtkToggleActionEntry entry;
    GtkToggleAction *action;
    PyObject *callback, *py_action;
    GClosure *closure;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:GtkActionGroup.add_toggle_actions",
				     kwlist, &entries, &extra_args))
        return NULL;
    
    if (!PySequence_Check(entries)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    state = pyg_gil_state_ensure();

    len = PySequence_Size(entries);
    for (i = 0; i < len; i++) {
	item = PySequence_GetItem(entries, i);
        Py_DECREF(item);

        memset(&entry, 0, sizeof(entry));
        callback = Py_None;
	
        if (!PyArg_ParseTuple(item, "s|zzzzOi", &(entry.name), &(entry.stock_id),
			      &(entry.label), &(entry.accelerator), &(entry.tooltip),
			      &callback, &(entry.is_active))) {
            return NULL;
        }

	action = gtk_toggle_action_new(entry.name, entry.label, entry.tooltip,
				       entry.stock_id);
	if (action == NULL) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GtkToggleAction object");
	    return NULL;
	}

	gtk_toggle_action_set_active(action, entry.is_active);
	py_action = pygobject_new((GObject *)action);
	if (callback != Py_None && PyCallable_Check(callback)) {
	    closure = pyg_closure_new(callback, extra_args, NULL);
	    g_signal_connect_closure(action, "activate", closure, FALSE);
	    pygobject_watch_closure(py_action, closure);
	}
	
	gtk_action_group_add_action_with_accel (GTK_ACTION_GROUP(self->obj),
						GTK_ACTION(action),
						entry.accelerator);
	
	g_object_unref (action);
	Py_DECREF (py_action);
    }

    pyg_gil_state_release(state);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_action_group_add_radio_actions kwargs
static PyObject *
_wrap_gtk_action_group_add_radio_actions (PyGObject *self, PyObject *args,
					  PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "value", "on_change", "user_data", NULL };
    PyGILState_STATE state;
    PyObject *entries, *extra_args = NULL;
    int len, i;
    PyObject *item;
    GtkRadioActionEntry entry;
    GtkRadioAction *action, *first_action = NULL;
    PyObject *callback = Py_None;
    GClosure *closure;
    GSList * group = NULL;
    gint value = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O|iOO:GtkActionGroup.add_radio_actions",
				     kwlist, &entries, &value, &callback, &extra_args))
        return NULL;
    
    if (!PySequence_Check(entries)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    state = pyg_gil_state_ensure();
    
    len = PySequence_Size(entries);
    for (i = 0; i < len; i++) {
	item = PySequence_GetItem(entries, i);
        Py_DECREF(item);

        memset(&entry, 0, sizeof(entry));
	
        if (!PyArg_ParseTuple(item, "s|zzzzi", &(entry.name),
			      &(entry.stock_id),
			      &(entry.label), &(entry.accelerator),
			      &(entry.tooltip),
			      &(entry.value))) {
            return NULL;
        }

	action = gtk_radio_action_new(entry.name, entry.label, entry.tooltip,
				      entry.stock_id, entry.value);
	if (action == NULL) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GtkRadioAction object");
	    return NULL;
	}

	gtk_radio_action_set_group(action, group);
	group = gtk_radio_action_get_group(action);

	if (value == entry.value)
	    gtk_toggle_action_set_active(GTK_TOGGLE_ACTION(action), TRUE);

	gtk_action_group_add_action_with_accel (GTK_ACTION_GROUP(self->obj),
						GTK_ACTION(action),
						entry.accelerator);
	
	if (i == 0)
	    first_action = action;
	else
	    g_object_unref (action);
    }

    if (first_action && callback != Py_None && PyCallable_Check(callback)) {
	PyObject *py_action;

	closure = pyg_closure_new(callback, extra_args, NULL);
	g_signal_connect_closure(first_action, "changed", closure, FALSE);
	py_action = pygobject_new((GObject *)first_action);
	pygobject_watch_closure(py_action, closure);
	g_object_unref(first_action);
	Py_DECREF (py_action);
    }
    
    pyg_gil_state_release(state);
	
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_ui_manager_add_ui_from_string kwargs
static PyObject *
_wrap_gtk_ui_manager_add_ui_from_string(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", NULL };
    char *buffer;
    Py_ssize_t length;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s#:GtkUIManager.add_ui_from_string",
				     kwlist, &buffer, &length))
        return NULL;
    
    ret = gtk_ui_manager_add_ui_from_string(GTK_UI_MANAGER(self->obj),
					    buffer, length, &error);
    if (pyg_error_check(&error))
        return NULL;
    return PyLong_FromLong(ret);
}
%%
override gtk_action_group_list_actions noargs
static PyObject *
_wrap_gtk_action_group_list_actions(PyGObject *self)
{
    GList *l, *actions;
    PyObject *item, *ret;

    ret = PyList_New(0);
    if (ret == NULL)
	return NULL;
    
    actions = gtk_action_group_list_actions(GTK_ACTION_GROUP(self->obj));

    for (l = actions; l; l = l->next) {
        item = pygobject_new((GObject *) GTK_ACTION(l->data));

        if (!item) {
            Py_DECREF(ret);
            return NULL;
        }

        PyList_Append(ret, item);
        Py_DECREF(item);
    }

    g_list_free(actions);
    
    return ret;
}
%%
override gtk_alignment_get_padding noargs
static PyObject *
_wrap_gtk_alignment_get_padding(PyGObject *self)
{
    guint top, bottom, left, right;

    gtk_alignment_get_padding(GTK_ALIGNMENT(self->obj), &top, &bottom, &left,
			      &right);
    return Py_BuildValue("(iiii)", top, bottom, left, right);
}
%%
override gtk_accel_group_connect_by_path kwargs
static PyObject *
_wrap_gtk_accel_group_connect_by_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", "callback", NULL };
    gchar *accel_path;
    PyObject *py_callback;
    GClosure *closure;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "sO:GtkAccelGroup.connect_by_path", kwlist,
				     &accel_path, &py_callback))
        return NULL;
    if (!PyCallable_Check(py_callback)) {
	PyErr_SetString(PyExc_TypeError, "callback argument not callable");
	return NULL;
    }
    closure = pyg_closure_new(py_callback, NULL, NULL);
    pygobject_watch_closure((PyObject *)self, closure);
    gtk_accel_group_connect_by_path(GTK_ACCEL_GROUP(self->obj), accel_path,
				    closure);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_color_button_new kwargs
static int
_wrap_gtk_color_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "color", NULL };
    GdkColor *color = NULL;
    PyObject *pycolor = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|O:GtkColorButton.__init__",
                                     kwlist, &pycolor))
        return -1;
    if (pycolor) {
 	if (!pyg_boxed_check(pycolor, GDK_TYPE_COLOR)) {
	    PyErr_SetString(PyExc_TypeError,
			    "color should be a gtk.gdk.Color");
 		return -1;
	    }
        color = pyg_boxed_get(pycolor, GdkColor);
        pygobject_construct(self, "color", color, NULL);
    } else {
        pygobject_construct(self, NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkColorButton object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_COLOR_BUTTON
%%
override gtk_color_button_get_color noargs
static PyObject *
_wrap_gtk_color_button_get_color(PyGObject *self)
{
    GdkColor color = {0, 0, 0, 0};
 
    gtk_color_button_get_color(GTK_COLOR_BUTTON(self->obj), &color);
    return pyg_boxed_new(GDK_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override gtk_combo_box_new kwargs
static int
_wrap_gtk_combo_box_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", NULL };
    PyGObject *pymodel = NULL;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkComboBox.__init__",
				     kwlist, &pymodel))
        return -1;
    if (pymodel == NULL || (PyObject *)pymodel == Py_None)
        pygobject_construct(self, NULL);
    else if (pygobject_check(pymodel, &PyGtkTreeModel_Type))
        pygobject_construct(self, "model", GTK_TREE_MODEL(pymodel->obj), NULL);
    else {
	PyErr_SetString(PyExc_TypeError,
			"model must be a gtk.TreeModel or None");
	return -1;
    }
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkComboBox object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_COMBO_BOX
%%
override gtk_combo_box_get_active_iter noargs
static PyObject *
_wrap_gtk_combo_box_get_active_iter(PyGObject *self)
{
    GtkTreeIter iter;
    gboolean ret;

    ret = gtk_combo_box_get_active_iter(GTK_COMBO_BOX(self->obj), &iter);

    if (ret)
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_cell_layout_set_attributes kwargs
static PyObject *
_wrap_gtk_cell_layout_set_attributes(PyGObject *self, PyObject *args,
                                          PyObject *kwargs)
{
    PyObject *py_cell, *key, *item;
    GtkCellRenderer *cell;
    Py_ssize_t i = 0;

    if (!PyArg_ParseTuple(args, "O!:GtkCellLayout.set_attributes",
                          &PyGtkCellRenderer_Type, &py_cell))
        return NULL;
    cell = GTK_CELL_RENDERER(pygobject_get(py_cell));
    gtk_cell_layout_clear_attributes(GTK_CELL_LAYOUT(self->obj), cell);
    if (kwargs) {
        while (PyDict_Next(kwargs, &i, &key, &item)) {
            gchar *attr = PyUnicode_AsUTF8(key);

            if (!PyLong_Check(item)) {
                gchar err[128];
                g_snprintf(err, sizeof(err),
                           "%s must be an integer column number", attr);
                PyErr_SetString(PyExc_TypeError, err);
                return NULL;
            }
            gtk_cell_layout_add_attribute(GTK_CELL_LAYOUT(self->obj),
					  cell, attr, PyLong_AsLong(item));
        }
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_combo_box_entry_new kwargs
static int
_wrap_gtk_combo_box_entry_new(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "model", "column", NULL };
    PyGObject *pymodel = NULL;
    gint column = 0;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Oi:GtkComboBoxEntry.__init__",
				     kwlist, &pymodel, &column))
        return -1;
    if ((PyObject*)pymodel == Py_None || pymodel == NULL)
        pygobject_construct(self, NULL);
    else if (pygobject_check(pymodel, &PyGtkTreeModel_Type)) {
	gint ncol = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(pymodel->obj));

	if (column < 0 || column >= ncol) {
	    PyErr_SetString(PyExc_ValueError, "column value out of range");
	    return -1;
	}
        pygobject_construct(self, "model", GTK_TREE_MODEL(pymodel->obj),
                            "text-column", column, NULL);
    } else {
	PyErr_SetString(PyExc_TypeError,
			"model must be a gtk.TreeModel or None");
	return -1;
    }
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkComboBoxEntry object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_COMBO_BOX_ENTRY
%%
override gtk_entry_completion_set_match_func args
static gboolean
pygtk_entry_completion_match_func_cb(GtkEntryCompletion *completion,
				      const gchar *key,
				      GtkTreeIter *iter,
				      gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_completion, *py_iter;
    gboolean ret = FALSE;
    PyObject *retobj;
 
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
 
    py_completion = pygobject_new((GObject *)completion);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, TRUE, TRUE);

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NsNO)", py_completion,
                                     key, py_iter, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NsN)", py_completion,
                                     key, py_iter);
    }

    if (retobj != NULL) {
	ret = PyObject_IsTrue(retobj);
        Py_DECREF(retobj);
    } else {
	PyErr_Print();
    }
 
    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_entry_completion_set_match_func(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
 
    if (!PyArg_ParseTuple(args,
                          "O|O:GtkEntryCompletion.set_match_func",
                          &pyfunc, &pyarg))
        return NULL;
 
    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);

    gtk_entry_completion_set_match_func(GTK_ENTRY_COMPLETION(self->obj),
					pygtk_entry_completion_match_func_cb,
					cunote, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_file_chooser_get_filenames noargs
static PyObject *
_wrap_gtk_file_chooser_get_filenames(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = PyUnicode_FromString((char *)tmp->data);
        if (obj == NULL) {
	    g_slist_foreach(slist, (GFunc)g_free, NULL);
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
    return py_list;
}
%%
override gtk_file_chooser_get_uris noargs
static PyObject *
_wrap_gtk_file_chooser_get_uris(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_get_uris(GTK_FILE_CHOOSER(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = PyUnicode_FromString((char *)tmp->data);
        if (obj == NULL) {
	    g_slist_foreach(slist, (GFunc)g_free, NULL);
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
    return py_list;
}
%%
override gtk_file_chooser_list_filters noargs
static PyObject *
_wrap_gtk_file_chooser_list_filters(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_list_filters(GTK_FILE_CHOOSER(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = pygobject_new(G_OBJECT(tmp->data));
        if (obj == NULL) {
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_free(slist);
    return py_list;
}
%%
override gtk_file_chooser_list_shortcut_folder_uris noargs
static PyObject *
_wrap_gtk_file_chooser_list_shortcut_folder_uris(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_list_shortcut_folder_uris(GTK_FILE_CHOOSER(self->obj));

    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = PyUnicode_FromString((char *)tmp->data);
        if (obj == NULL) {
	    g_slist_foreach(slist, (GFunc)g_free, NULL);
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
    return py_list;
}
%%
override gtk_file_chooser_list_shortcut_folders noargs
static PyObject *
_wrap_gtk_file_chooser_list_shortcut_folders(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_list_shortcut_folders(GTK_FILE_CHOOSER(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = PyUnicode_FromString((char *)tmp->data);
        if (obj == NULL) {
	    g_slist_foreach(slist, (GFunc)g_free, NULL);
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
    return py_list;
}
%%
override gtk_file_chooser_widget_new kwargs
static int
_wrap_gtk_file_chooser_widget_new(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "action", "backend", NULL };
    PyObject *py_action = NULL;
    gchar * backend = NULL;
    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|Oz:GtkFileChooserWidget.__init__",
				     kwlist, &py_action, &backend))
        return -1;
    if (py_action && pyg_enum_get_value(GTK_TYPE_FILE_CHOOSER_ACTION,
					py_action, (gint *)&action))
        return -1;
        pygobject_construct(self,
                            "action", action, "file-system-backend", backend,
                            NULL);
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkFileChooserWidget object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_FILE_CHOOSER_WIDGET
%%
override gtk_file_filter_filter kwargs
static PyObject *
_wrap_gtk_file_filter_filter(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "filter_info", NULL };
    GtkFileFilterInfo filter_info = { 0, NULL, NULL, NULL, NULL };
    PyObject *py_filter_info, *obj;
    PyObject *pyret = Py_False;
    int size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkFileFilter.filter", kwlist,
				     &PyTuple_Type, &py_filter_info))
        return NULL;

    size = PyTuple_Size(py_filter_info);
    if (size != 4) {
	PyErr_SetString(PyExc_RuntimeError,
                        "filter_info tuple must contain 4 items"
			" each of type string or None");
	return NULL;
    }

    if ((obj = PyTuple_GetItem(py_filter_info, 0)) != Py_None) {
	if (!PyUnicode_Check(obj))
	    goto error;
	filter_info.filename = PyUnicode_AsUTF8(obj);
	filter_info.contains |= GTK_FILE_FILTER_FILENAME;
    }
    if ((obj = PyTuple_GetItem(py_filter_info, 1)) != Py_None) {
	if (!PyUnicode_Check(obj))
	    goto error;
	filter_info.uri = PyUnicode_AsUTF8(obj);
	filter_info.contains |= GTK_FILE_FILTER_URI;
    }
    if ((obj = PyTuple_GetItem(py_filter_info, 2)) != Py_None) {
	if (!PyUnicode_Check(obj))
	    goto error;
	filter_info.display_name = PyUnicode_AsUTF8(obj);
	filter_info.contains |= GTK_FILE_FILTER_DISPLAY_NAME;
    }
    if ((obj = PyTuple_GetItem(py_filter_info, 3)) != Py_None) {
	if (!PyUnicode_Check(obj))
	    goto error;
	filter_info.mime_type = PyUnicode_AsUTF8(obj);
	filter_info.contains |= GTK_FILE_FILTER_MIME_TYPE;
    }

    if (gtk_file_filter_filter(GTK_FILE_FILTER(self->obj), &filter_info))
	pyret = Py_True;
    Py_INCREF(pyret);
    return pyret;

 error:
    PyErr_SetString(PyExc_TypeError, "filter_info 4-tuple items"
		    " must be of type string or None");
    return NULL;
}
%%
override gtk_file_filter_add_custom args
static gboolean
pygtk_file_filter_add_custom_cb(const GtkFileFilterInfo *filter_info,
				gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    gboolean ret = FALSE;
    PyObject *retobj, *py_filter_info, *py_obj;
 
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_filter_info = PyTuple_New(4);

    if (filter_info->filename
	&& (filter_info->contains & GTK_FILE_FILTER_FILENAME)) {
	py_obj = PyUnicode_FromString(filter_info->filename);
    } else {
	Py_INCREF(Py_None);
	py_obj = Py_None;
    }
    PyTuple_SetItem(py_filter_info, 0, py_obj);
    if (filter_info->uri
	&& (filter_info->contains & GTK_FILE_FILTER_URI)) {
	py_obj = PyUnicode_FromString(filter_info->uri);
    } else {
	Py_INCREF(Py_None);
	py_obj = Py_None;
    }
    PyTuple_SetItem(py_filter_info, 1, py_obj);
    if (filter_info->display_name
	&& (filter_info->contains & GTK_FILE_FILTER_DISPLAY_NAME)) {
	py_obj = PyUnicode_FromString(filter_info->display_name);
    } else {
	Py_INCREF(Py_None);
	py_obj = Py_None;
    }
    PyTuple_SetItem(py_filter_info, 2, py_obj);
    if (filter_info->mime_type
	&& (filter_info->contains & GTK_FILE_FILTER_MIME_TYPE)) {
	py_obj = PyUnicode_FromString(filter_info->mime_type);
    } else {
	Py_INCREF(Py_None);
	py_obj = Py_None;
    }
    PyTuple_SetItem(py_filter_info, 3, py_obj);
 
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NO)", py_filter_info,
				     cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(N)", py_filter_info);
    }

    if (retobj != NULL) {
	ret = PyObject_IsTrue(retobj);
        Py_DECREF(retobj);
    } else {
	PyErr_Print();
    }
 
    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_file_filter_add_custom(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyflags, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
    GtkFileFilterFlags flags;
 
    if (!PyArg_ParseTuple(args,
                          "OO|O:GtkEntryCompletion.set_match_func",
                          &pyflags, &pyfunc, &pyarg))
        return NULL;
 
    if (pyg_flags_get_value(GTK_TYPE_FILE_FILTER_FLAGS, pyflags,
			   (gint *)&flags))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);

    gtk_file_filter_add_custom(GTK_FILE_FILTER(self->obj), flags,
			       pygtk_file_filter_add_custom_cb,
			       cunote, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_font_button_new kwargs
static int
_wrap_gtk_font_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fontname", NULL };
    gchar * fontname = NULL;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkFontButton.__init__",
				     kwlist, &fontname))
        return -1;

    if (fontname == NULL)
        pygobject_construct(self, NULL);
    else
        pygobject_construct(self, "font-name", fontname, NULL);
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkFontButton object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_FONT_BUTTON
%%
override gtk_action_get_proxies noargs
static PyObject *
_wrap_gtk_action_get_proxies(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_action_get_proxies(GTK_ACTION(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = pygobject_new(G_OBJECT(tmp->data));
        if (obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    return py_list;
}
%%
override gtk_clipboard_wait_for_targets noargs
static PyObject *
_wrap_gtk_clipboard_wait_for_targets(PyGObject *self)
{
    GtkSelectionData *data;

    /* have to work around GTK+ bug #139883 */
    data = gtk_clipboard_wait_for_contents(GTK_CLIPBOARD(self->obj),
					   gdk_atom_intern("TARGETS", FALSE));

    if (data) {
	gint n_targets = 0;
	GdkAtom *targets = NULL;
    
	if (gtk_selection_data_get_targets(data, &targets, &n_targets)) {
	    PyObject *ret;
	    int i;

	    ret = PyTuple_New(n_targets);
	    for (i = 0; i < n_targets; i++) {
                gchar *name;

                name = gdk_atom_name(targets[i]);
		PyTuple_SetItem(ret, i, PyUnicode_FromString(name));
                g_free(name);
            }
	    g_free(targets);
	    gtk_selection_data_free(data);
	    return ret;
	}
	gtk_selection_data_free(data);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_request_contents kwargs
static void
clipboard_request_contents_cb(GtkClipboard *clipboard,
			      GtkSelectionData *selection_data,
			      gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)clipboard),
			 pyg_boxed_new(GTK_TYPE_SELECTION_DATA,
				       selection_data, TRUE, TRUE),
			 PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF((PyObject *)user_data);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_request_contents(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "target", "callback", "user_data", NULL };
    PyObject *py_target, *callback, *data, *user_data = Py_None;
    GdkAtom target;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|O:GtkClipboard.request_contents",
				     kwlist, &py_target, &callback,
				     &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }
    target = pygdk_atom_from_pyobject(py_target);
    if (PyErr_Occurred())
        return NULL;

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_contents(GTK_CLIPBOARD(self->obj), target,
				   clipboard_request_contents_cb,
				   (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_request_text kwargs
static void
clipboard_request_text_cb(GtkClipboard *clipboard,
			  const gchar *text,
			  gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret, *py_text, *data;
 
    data = (PyObject *) user_data;

    if (text) {
        py_text = PyUnicode_FromString(text);
    } else {
        py_text = Py_None;
        Py_INCREF(Py_None);
    }

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem(data, 0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)clipboard),
                         py_text,
			 PyTuple_GetItem(data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(data);
    Py_DECREF(args);
    pyg_gil_state_release(state);
}

static PyObject *
_wrap_gtk_clipboard_request_text(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "callback", "user_data", NULL };
    PyObject *callback, *data, *user_data = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkClipboard.request_text",
				     kwlist, &callback, &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_text(GTK_CLIPBOARD(self->obj),
			       clipboard_request_text_cb,
			       (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_request_targets kwargs
static void
clipboard_request_targets_cb(GtkClipboard *clipboard,
			     GdkAtom *atoms,
			     gint n_atoms,
			     gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret, *py_atoms;
    int i;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    if (atoms) {
        py_atoms = PyTuple_New(n_atoms);
        for (i = 0; i < n_atoms; i++) {
            gchar *name;

            name = gdk_atom_name(atoms[i]);
            PyTuple_SetItem(py_atoms, i, PyUnicode_FromString(name));
            g_free(name);
        }
    } else
        py_atoms = PyTuple_New(0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)clipboard),
			 py_atoms,
			 PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF((PyObject *)user_data);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_request_targets(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "callback", "user_data", NULL };
    PyObject *callback, *data, *user_data = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkClipboard.request_targets",
				     kwlist, &callback, &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_targets(GTK_CLIPBOARD(self->obj),
				   clipboard_request_targets_cb,
				   (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_icon_size_lookup_for_settings kwargs
static PyObject *
_wrap_gtk_icon_size_lookup_for_settings(PyGObject *self, PyObject *args,
					PyObject *kwargs)
{
    static char *kwlist[] = { "settings", "icon_size", NULL };
    PyObject *py_settings, *py_icon_size;
    GtkSettings *settings;
    GtkIconSize icon_size;
    gint width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!O:icon_size_lookupfor settings",
                                     kwlist, &PyGtkSettings_Type,
				     &py_settings, &py_icon_size))
        return NULL;

    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_icon_size,
                           (gint *) &icon_size))
        return NULL;

    settings = GTK_SETTINGS(pygobject_get(py_settings));
    if (gtk_icon_size_lookup_for_settings(settings, icon_size,
					  &width, &height))
	return Py_BuildValue("(ii)", width, height);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_icon_theme_set_search_path kwargs
static PyObject *
_wrap_gtk_icon_theme_set_search_path(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    int i, len;
    PyObject *py_seq;
    gchar **paths;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,
				     "O:GtkIconTheme.set_search_path",
                                     kwlist, &py_seq))
        return NULL;

    if (!PySequence_Check(py_seq) || (len = PySequence_Size(py_seq)) < 0) {
	PyErr_SetString(PyExc_ValueError,
			"path should be a sequence of strings");
	return NULL;
    }

    paths = g_new(gchar *, len);
    for (i = 0; i < len; i++) {
	PyObject *py_path = PySequence_GetItem(py_seq, i);
	if (!PyUnicode_Check(py_path)) {
	    PyErr_SetString(PyExc_ValueError, "path items must be strings");
	    Py_DECREF(py_path);
	    g_free(paths);
	    return NULL;
	}
	paths[i] = PyUnicode_AsUTF8(py_path);
	Py_DECREF(py_path);
    }

    gtk_icon_theme_set_search_path(GTK_ICON_THEME(self->obj),
				   (const gchar **)paths, len);

    g_free(paths);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_icon_theme_get_search_path noargs
static PyObject *
_wrap_gtk_icon_theme_get_search_path(PyGObject *self)
{
    gchar **paths;
    gint n_items;
    PyObject *py_tuple;
    int i;

    gtk_icon_theme_get_search_path(GTK_ICON_THEME(self->obj),
				   &paths, &n_items);

    py_tuple = PyTuple_New(n_items);
    for (i = 0; i < n_items; i++)
	PyTuple_SetItem(py_tuple, i, PyUnicode_FromString(paths[i]));

    g_strfreev(paths);

    return py_tuple;
}
%%
override gtk_icon_theme_list_icons kwargs
static PyObject *
_wrap_gtk_icon_theme_list_icons(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "context", NULL };
    GList *icons;
    gchar *context = NULL;
    int i;
    guint len;
    PyObject *py_icons;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkIconTheme.list_icons",
                                     kwlist, &context))
        return NULL;

    icons = gtk_icon_theme_list_icons(GTK_ICON_THEME(self->obj), context);
    len = g_list_length(icons);

    py_icons = PyTuple_New(len);

    for (i = 0; i < len; i++) {
	char *name = (char *)g_list_nth_data(icons, i);

	PyTuple_SetItem(py_icons, i, PyUnicode_FromString(name));
    }
    g_list_foreach(icons, (GFunc)g_free, NULL);
    g_list_free(icons);

    return py_icons;
}
%%
override gtk_icon_info_get_embedded_rect noargs
static PyObject *
_wrap_gtk_icon_info_get_embedded_rect(PyGObject *self)
{
    GdkRectangle rect;
    int ret;

    ret = gtk_icon_info_get_embedded_rect(pyg_boxed_get(self, GtkIconInfo),
					  &rect);

    if (ret)
	return pyg_boxed_new(GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_icon_info_get_attach_points noargs
static PyObject *
_wrap_gtk_icon_info_get_attach_points(PyGObject *self)
{
    GdkPoint *points;
    gint n_points;
    int ret;
    PyObject *py_points;

    ret = gtk_icon_info_get_attach_points(pyg_boxed_get(self, GtkIconInfo),
					  &points, &n_points);
    if (ret) {
	int i;

	py_points = PyTuple_New(n_points);
	for (i = 0; i < n_points; i++)
	    PyTuple_SetItem(py_points, i, Py_BuildValue("(ii)",
							points[i].x,
							points[i].y));
	g_free(points);
	return py_points;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_radio_action_set_group kwargs
static PyObject *
_wrap_gtk_radio_action_set_group(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "group", NULL };
    GSList *list;
    GtkRadioAction *group;
    PyObject *py_group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkRadioAction.set_group",
				     kwlist, &py_group))
        return NULL;

    if (pygobject_check(py_group, &PyGtkRadioAction_Type)) {
	group = GTK_RADIO_ACTION(pygobject_get(py_group));
	list = gtk_radio_action_get_group(group);
	if (list == gtk_radio_action_get_group(GTK_RADIO_ACTION(self->obj))) {
	    PyErr_SetString(PyExc_ValueError, "radio action already in group");
	    return NULL;
	}
    } else if (py_group == Py_None) {
	list = NULL;
    } else {
	PyErr_SetString(PyExc_TypeError, "group must be a RadioAction or None");
	return NULL;
    }

    gtk_radio_action_set_group(GTK_RADIO_ACTION(self->obj), list);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_radio_action_get_group noargs
static PyObject *
_wrap_gtk_radio_action_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_action_get_group(GTK_RADIO_ACTION(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
%%
override gtk_scale_get_layout_offsets noargs
static PyObject *
_wrap_gtk_scale_get_layout_offsets(PyGObject *self)
{
    gint x = 0, y = 0;

    gtk_scale_get_layout_offsets(GTK_SCALE(self->obj), &x, &y);

    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_tooltips_get_info_from_tip_window noargs
static PyObject *
_wrap_gtk_tooltips_get_info_from_tip_window(PyGObject *self)
{
    gboolean ret;
    GtkWidget *widget;
    GtkTooltips *tooltips;

    ret = gtk_tooltips_get_info_from_tip_window(GTK_WINDOW(self->obj),
						&tooltips, &widget);
    if (ret)
	return Py_BuildValue("(NN)",
			     pygobject_new((GObject *)tooltips),
			     pygobject_new((GObject *)widget));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_menu_item_toggle_size_request noargs
static PyObject *
_wrap_gtk_menu_item_toggle_size_request(PyGObject *self)
{
    gint requisition;

    gtk_menu_item_toggle_size_request(GTK_MENU_ITEM(self->obj), &requisition);

    return PyLong_FromLong(requisition);
}
%%
override gtk_entry_new kwargs
static int
_wrap_gtk_entry_new(PyGObject * self, PyObject * args, PyObject * kwargs)
{
    static char *kwlist[] = { "max", NULL };
    int max = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:GtkEntry.__init__",
                                     kwlist, &max))
	return -1;
    pygobject_construct(self, "max-length", max, NULL);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkEntry object");
	return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_ENTRY
%%
override gtk_accel_groups_from_object
static PyObject *
_wrap_gtk_accel_groups_from_object(PyGObject *self, PyObject *args)
{
    PyGObject *obj;
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *item;

    if (!PyArg_ParseTuple(args, "O!:accel_group_from_object",
			  &PyGObject_Type, &obj))
	return NULL;
    
    list = gtk_accel_groups_from_object(G_OBJECT(obj->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    
    for (tmp = list; tmp; tmp = tmp->next) {
        item = pygobject_new(G_OBJECT(tmp->data));
        if (item == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, item);
        Py_DECREF(item);
    }
    
    return py_list;
}
%%
override gtk_table_new kwargs
static int
_wrap_gtk_table_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    char *arg_names[] = {"rows", "columns", "homogeneous", NULL };
    int rows = 1, cols = 1;
    PyObject *homogeneous = Py_False;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iiO:gtk.Table.__init__", arg_names,
                                     &rows, &cols, &homogeneous))
        return -1;
    pygobject_construct(self, "n_rows", rows, "n_columns", cols,
                        "homogeneous", PyObject_IsTrue(homogeneous), NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create gtk.Table object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_TABLE
%%
override gtk_pixmap_new kwargs
static int
_wrap_gtk_pixmap_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixmap", "mask", NULL };
    PyGObject *pixmap, *py_mask;
    GdkPixmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O:GtkPixmap.__init__",
                                     kwlist, &PyGdkPixmap_Type, &pixmap, &py_mask))
        return -1;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkImage") < 0)
        return -1;
    if (py_mask && pygobject_check(py_mask, &PyGdkPixmap_Type))
        mask = GDK_PIXMAP(py_mask->obj);
    else if ((PyObject *)py_mask != Py_None) {
        PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap or None");
        return -1;
    }

    pygobject_construct(self, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkPixmap object");
        return -1;
    }

    gtk_pixmap_set(GTK_PIXMAP(self->obj), GDK_PIXMAP(pixmap->obj), mask);

    return 0;
}
%%
new-constructor GTK_TYPE_PIXMAP
%%
override gtk_plug_new kwargs
static int
_wrap_gtk_plug_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "socket_id", "display", NULL };
    gulong socket_id;
    PyGObject *display = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "k|O!:GtkPlug.__init__", kwlist,
                                     &socket_id, &PyGdkDisplay_Type, &display))
        return -1;

    pygobject_construct(self, NULL);

    if (display)
        gtk_plug_construct_for_display(GTK_PLUG(self->obj),
                                       GDK_DISPLAY(display->obj), socket_id);
    else
        gtk_plug_construct(GTK_PLUG(self->obj), socket_id);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkPlug object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_PLUG
%%
override gtk_adjustment_new kwargs
static int
_wrap_gtk_adjustment_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    char *kwlist[] = {"value", "lower", "upper", "step_incr",
                      "page_incr", "page_size", NULL };
    gdouble value = 0;
    gdouble lower = 0;
    gdouble upper = 0;
    gdouble step_incr = 0;
    gdouble page_incr = 0;
    gdouble page_size = 0;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|dddddd:gtk.Adjustment.__init__" ,
                                     kwlist, &value, &lower, &upper, &step_incr,
                                     &page_incr, &page_size))
        return -1;

    pygobject_construct(self, "lower", lower, "upper", upper,
                        "step_increment", step_incr,
                        "page_increment", page_incr,
                        "page_size", page_size,
                        "value", value, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create gtk.Adjustment object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_ADJUSTMENT
%%
override gtk_alignment_new kwargs
static int
_wrap_gtk_alignment_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    char *kwlist[] = {"xalign", "yalign", "xscale", "yscale", NULL };
    gdouble xalign = 0;
    gdouble yalign = 0;
    gdouble xscale = 0;
    gdouble yscale = 0;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|dddd:gtk.Alignment.__init__" ,
                                     kwlist, &xalign, &yalign, &xscale, &yscale))
        return -1;

    pygobject_construct(self, "xalign", xalign, "yalign", yalign,
                        "xscale", xscale, "yscale", yscale, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create gtk.Alignment object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_ALIGNMENT
%%
override gtk_about_dialog_set_authors kwargs
static PyObject *
_wrap_gtk_about_dialog_set_authors(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    gchar **authors = NULL;
    static char *kwlist[] = { "authors", NULL };
    PyObject *py_authors = NULL;
    int i, n_authors;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "O:GtkAboutDialog.set_authors",
                                     kwlist, &py_authors))
        return NULL;

    if (!PySequence_Check(py_authors)) {
        PyErr_SetString(PyExc_TypeError, "authors must be a sequence");
        return NULL;
    }

    n_authors = PySequence_Length(py_authors);
    authors = g_new(gchar *, n_authors + 1);
    for (i = 0; i < n_authors; i++) {
        PyObject *item = PySequence_GetItem(py_authors, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        authors[i] = PyUnicode_AsUTF8(item);
    }
    authors[n_authors] = NULL;

    gtk_about_dialog_set_authors(GTK_ABOUT_DIALOG(self->obj),
                                 (const char **)authors);

    g_free(authors);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_about_dialog_get_authors noargs
static PyObject *
_wrap_gtk_about_dialog_get_authors(PyGObject *self)
{
    gchar **authors, **tmp;
    int i = 0, j;
    PyObject *ret;

    authors = (gchar **)gtk_about_dialog_get_authors(GTK_ABOUT_DIALOG(self->obj));
    if (!authors)
	return PyTuple_New(0);
    
    tmp = authors;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyUnicode_FromString(authors[j]));

    return ret;
}
%%
override gtk_about_dialog_set_documenters kwargs
static PyObject *
_wrap_gtk_about_dialog_set_documenters(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    gchar **documenters = NULL;
    static char *kwlist[] = { "documenters", NULL };
    PyObject *py_documenters = NULL;
    int i, n_documenters;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "O:GtkAboutDialog.set_documenters",
                                     kwlist, &py_documenters))
        return NULL;

    if (!PySequence_Check(py_documenters)) {
        PyErr_SetString(PyExc_TypeError, "documenters must be a sequence");
        return NULL;
    }

    n_documenters = PySequence_Length(py_documenters);
    documenters = g_new(gchar *, n_documenters + 1);
    for (i = 0; i < n_documenters; i++) {
        PyObject *item = PySequence_GetItem(py_documenters, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        documenters[i] = PyUnicode_AsUTF8(item);
    }
    documenters[n_documenters] = NULL;

    gtk_about_dialog_set_documenters(GTK_ABOUT_DIALOG(self->obj),
                                     (const char **)documenters);

    g_free(documenters);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_about_dialog_get_documenters noargs
static PyObject *
_wrap_gtk_about_dialog_get_documenters(PyGObject *self)
{
    gchar **documenters, **tmp;
    int i = 0, j;
    PyObject *ret;

    documenters = (gchar **)gtk_about_dialog_get_documenters(GTK_ABOUT_DIALOG(self->obj));
    if (!documenters)
	return PyTuple_New(0);
    
    tmp = documenters;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyUnicode_FromString(documenters[j]));

    return ret;
}
%%
override gtk_about_dialog_set_artists kwargs
static PyObject *
_wrap_gtk_about_dialog_set_artists(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    gchar **artists = NULL;
    static char *kwlist[] = { "artists", NULL };
    PyObject *py_artists = NULL;
    int i, n_artists;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "O:GtkAboutDialog.set_artists",
                                     kwlist, &py_artists))
        return NULL;

    if (!PySequence_Check(py_artists)) {
        PyErr_SetString(PyExc_TypeError, "artists must be a sequence");
        return NULL;
    }

    n_artists = PySequence_Length(py_artists);
    artists = g_new(gchar *, n_artists + 1);
    for (i = 0; i < n_artists; i++) {
        PyObject *item = PySequence_GetItem(py_artists, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        artists[i] = PyUnicode_AsUTF8(item);
    }
    artists[n_artists] = NULL;

    gtk_about_dialog_set_artists(GTK_ABOUT_DIALOG(self->obj),
                                 (const char **)artists);

    g_free(artists);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_about_dialog_get_artists noargs
static PyObject *
_wrap_gtk_about_dialog_get_artists(PyGObject *self)
{
    gchar **artists, **tmp;
    int i = 0, j;
    PyObject *ret;

    artists = (gchar **)gtk_about_dialog_get_artists(GTK_ABOUT_DIALOG(self->obj));
    if (!artists)
	return PyTuple_New(0);
    
    tmp = artists;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyUnicode_FromString(artists[j]));

    return ret;
}
%%
override gtk_show_about_dialog kwargs
static PyObject *
_wrap_gtk_show_about_dialog(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkWindow *parent;
    PyGObject *py_window = NULL;
    GtkWidget *dialog;
    GObjectClass *klass;

    if (!PyArg_ParseTuple (args, "O:Gtk.show_about_dialog", &py_window))
        return NULL;

    if (py_window == NULL || (PyObject*)py_window == Py_None)
        parent = NULL;
    else
        parent = GTK_WINDOW (py_window->obj);

    dialog = gtk_about_dialog_new ();

    g_signal_connect (dialog, "response",
                      G_CALLBACK (gtk_widget_destroy), NULL);

    if (kwargs) {
        Py_ssize_t pos = 0;
        PyObject *py_prop_name;
        PyObject *py_prop_value;

        while (PyDict_Next (kwargs, &pos, &py_prop_name, &py_prop_value)) {
            GParamSpec *pspec;
            const gchar *property_name;
            GValue property_gvalue = { 0, };

            property_name = PyUnicode_AsUTF8 (py_prop_name);

            klass = G_OBJECT_CLASS (GTK_ABOUT_DIALOG_GET_CLASS(dialog));

            pspec = g_object_class_find_property (klass, property_name);
            if (!pspec) {
                PyErr_Format(PyExc_TypeError,
                             "Gtk.AboutDialog doesn't support property `%s'",
                             property_name);
                goto arg_error;
            }

            g_value_init (&property_gvalue, G_PARAM_SPEC_VALUE_TYPE(pspec));
            if (pyg_param_gvalue_from_pyobject(&property_gvalue,
                                               py_prop_value, pspec) < 0) {
                PyErr_Format(PyExc_TypeError,
                             "could not convert value for property `%s'",
                             property_name);
                g_value_unset (&property_gvalue);
                goto arg_error;
            }

            g_object_set_property (G_OBJECT (dialog), property_name,
                                   &property_gvalue);
            g_value_unset (&property_gvalue);
        }
    }

    if (parent) {
        gtk_window_set_transient_for (GTK_WINDOW (dialog), parent);
        gtk_window_set_destroy_with_parent (GTK_WINDOW (dialog), TRUE);
    }

    gtk_window_present (GTK_WINDOW (dialog));

    Py_INCREF(Py_None);
    return Py_None;

arg_error:
    if (dialog)
        gtk_widget_destroy (dialog);

    return NULL;
}
%%
override gtk_selection_data_set_uris kwargs
static PyObject *
_wrap_gtk_selection_data_set_uris(PyGBoxed *self, PyObject *args,
				  PyObject *kwargs)
{
    gchar **uris = NULL;
    static char *kwlist[] = { "uris", NULL };
    PyObject *py_uris = NULL;
    int i, n_uris;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "O:GtkSelectionData.set_uris",
                                     kwlist, &py_uris))
        return NULL;

    if (!PySequence_Check(py_uris)) {
        PyErr_SetString(PyExc_TypeError, "uris must be a sequence");
        return NULL;
    }

    n_uris = PySequence_Length(py_uris);
    uris = g_new(gchar *, n_uris + 1);
    for (i = 0; i < n_uris; i++) {
        PyObject *item = PySequence_GetItem(py_uris, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        uris[i] = PyUnicode_AsUTF8(item);
    }
    uris[n_uris] = NULL;

    gtk_selection_data_set_uris(pyg_boxed_get(self, GtkSelectionData), uris);

    g_free(uris);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_selection_data_get_uris noargs
static PyObject *
_wrap_gtk_selection_data_get_uris(PyGBoxed *self)
{
    gchar **uris, **tmp;
    int i = 0, j;
    PyObject *ret;

    uris = gtk_selection_data_get_uris(pyg_boxed_get(self, GtkSelectionData));
    if (!uris)
	return PyTuple_New(0);
    
    tmp = uris;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyUnicode_FromString(uris[j]));

    return ret;
}
%%
override gtk_drag_source_get_target_list noargs
static PyObject *
_wrap_gtk_drag_source_get_target_list(PyGObject *self)
{
    GtkTargetList *target_list;

    target_list = gtk_drag_source_get_target_list(GTK_WIDGET(self->obj));

    if (!target_list) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return pygtk_target_list_to_list(target_list);
}
%%
override gtk_drag_source_set_target_list kwargs
static PyObject *
_wrap_gtk_drag_source_set_target_list(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "target_list", NULL };
    PyObject *py_targets;
    GtkTargetList *target_list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkWidget.drag_source_set_target_list",
                                     kwlist, &py_targets))
        return NULL;

    if (!(target_list = pygtk_target_list_from_sequence(py_targets)))
        return NULL;

    gtk_drag_source_set_target_list(GTK_WIDGET(self->obj), target_list);
    gtk_target_list_unref(target_list);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_cell_view_set_value kwargs
static PyObject *
_wrap_gtk_cell_view_set_value(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "renderer", "property", "value", NULL };
    PyObject *pyrenderer, *pyvalue;
    GtkCellRenderer *renderer;
    gchar *property;
    GParamSpec *pspec;
    GValue value = { 0 };
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!sO:GtkCellView.set_value",
                                     kwlist,
                                     &PyGtkCellRenderer_Type, &pyrenderer,
                                     &property, &pyvalue))
        return NULL;
 
    renderer = GTK_CELL_RENDERER(pygobject_get(pyrenderer));
    pspec = g_object_class_find_property(G_OBJECT_GET_CLASS(renderer),
                                         property);
    if (!pspec) {
         PyErr_Format(PyExc_TypeError,
                      "property %s is not defined for the renderer",
                      property);
        return NULL;
    }
    g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
    if (pyg_value_from_pyobject(&value, pyvalue)) {
        PyErr_Format(PyExc_TypeError,
                     "value is of the wrong type for property %s",
                     property);
        return NULL;
    }
    gtk_cell_view_set_value(GTK_CELL_VIEW(self->obj), renderer,
                            property, &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_cell_view_set_values kwargs
static PyObject *
_wrap_gtk_cell_view_set_values(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    PyObject *pyrenderer, *key, *item;
    GtkCellRenderer *renderer;
    GtkCellView *view;
    gchar *property;
    GParamSpec *pspec;
    GValue value = { 0 };
    gint i = 0;

    if (!PyArg_ParseTuple(args, "O!:GtkCellView.set_values",
                          &PyGtkCellRenderer_Type, &pyrenderer))
        return NULL;

    if (!kwargs) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    view = GTK_CELL_VIEW(self->obj);
    renderer = GTK_CELL_RENDERER(pygobject_get(pyrenderer));
    while (PyDict_Next(kwargs, &i, &key, &item)) {
        property = PyUnicode_AsUTF8(key);
        pspec = g_object_class_find_property(G_OBJECT_GET_CLASS(renderer),
                                             property);
        if (!pspec) {
            PyErr_Format(PyExc_TypeError,
                         "property %s is not defined for the renderer",
                         property);
            return NULL;
        }
        g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
        if (pyg_value_from_pyobject(&value, item)) {
            PyErr_Format(PyExc_TypeError,
                         "value is of the wrong type for property %s",
                         property);
            return NULL;
        }
        gtk_cell_view_set_value(view, renderer, property, &value);
        g_value_unset(&value);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_cell_view_get_cell_renderers noargs
static PyObject *
_wrap_gtk_cell_view_get_cell_renderers(PyGObject *self)
{
    GList *cell_list;
    PyObject *py_cell_list, *py_cell;
    GtkCellRenderer *cell;
    guint len;
    int i;

    cell_list = gtk_cell_view_get_cell_renderers(GTK_CELL_VIEW(self->obj));
    len = g_list_length(cell_list);
    py_cell_list = PyList_New(len);
    for (i = 0; i < len; i++) {
        cell = GTK_CELL_RENDERER(g_list_nth_data(cell_list, i));
        if (!cell || !(py_cell = pygobject_new(G_OBJECT(cell)))) {
            g_list_free(cell_list);
            Py_DECREF(py_cell_list);
            return NULL;
        }
        PyList_SetItem(py_cell_list, i, py_cell);
    }
    g_list_free(cell_list);
    return py_cell_list;
}
%%
override gtk_cell_view_get_size_of_row kwargs
static PyObject *
_wrap_gtk_cell_view_get_size_of_row(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreePath *path;
    GtkRequisition requisition;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkCellView.get_size_of_row",
                                     kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError,
                        "could not convert path to a GtkTreePath");
        return NULL;
    }
    gtk_cell_view_get_size_of_row(GTK_CELL_VIEW(self->obj), path,
                                  &requisition);
    gtk_tree_path_free(path);
    return pyg_boxed_new(GTK_TYPE_REQUISITION, &requisition, TRUE, TRUE);
}
%%
override gtk_clipboard_set_can_store kwargs
static PyObject *
_wrap_gtk_clipboard_set_can_store(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "targets", NULL };
    GtkTargetEntry *targets;
    PyObject *py_targets;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkClipboard.set_can_store",
                                     kwlist, &py_targets))
        return NULL;
    if (py_targets == Py_None) {
        targets = NULL;
        n_targets = 0;
    } else {
        if (!(py_targets = PySequence_Fast(py_targets,
                                       "targets must be a sequence")))
            return NULL;
        n_targets = PySequence_Fast_GET_SIZE(py_targets);
        targets = g_new(GtkTargetEntry, n_targets);
        for (i = 0; i < n_targets; i++) {
            PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
            if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                                  &targets[i].flags, &targets[i].info)) {
                PyErr_Clear();
                PyErr_SetString(PyExc_TypeError,
                                "list items should be of form (string,int,int)");
                g_free(targets);
                Py_DECREF(py_targets);
                return NULL;
            }
        }
        Py_DECREF(py_targets);
    }
    gtk_clipboard_set_can_store(GTK_CLIPBOARD(self->obj), targets, n_targets);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_combo_box_set_row_separator_func args
static gboolean
pygtk_combo_box_row_separator_func_cb(GtkTreeModel *model,
				      GtkTreeIter *iter,
				      gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_model, *py_iter;
    gboolean ret = FALSE;
    PyObject *retobj;
 
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
 
    py_model = pygobject_new((GObject *)model);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, TRUE, TRUE);

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NNO)", py_model,
                                     py_iter, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NN)", py_model, py_iter);
    }

    if (retobj != NULL) {
	ret = PyObject_IsTrue(retobj);
        Py_DECREF(retobj);
    } else {
	PyErr_Print();
    }
 
    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_combo_box_set_row_separator_func(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc = NULL, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
 
    if (!PyArg_ParseTuple(args,
                          "|OO:GtkComboBox.set_row_separator_func",
                          &pyfunc, &pyarg))
        return NULL;

    if (pyfunc == NULL || pyfunc == Py_None) {
        gtk_combo_box_set_row_separator_func(GTK_COMBO_BOX(self->obj),
                                             NULL, NULL, NULL);
    } else if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);

        gtk_combo_box_set_row_separator_func(
            GTK_COMBO_BOX(self->obj),
            pygtk_combo_box_row_separator_func_cb,
            cunote,
            pygtk_custom_destroy_notify);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_file_chooser_button_new kwargs
static int
_wrap_gtk_file_chooser_button_new(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist1[] = { "title", "backend", NULL };
    static char *kwlist2[] = { "dialog", NULL };
    gchar *title, *backend = NULL;
    PyGObject *dialog;
 
    if (PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s|z:GtkFileChooserButton.__init__",
				     kwlist1, &title, &backend))
        pygobject_construct(self, "title", title,
                            "file-system-backend", backend,
                            NULL);
    else {
        PyErr_Clear();
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "O!:GtkFileChooserButton.__init__",
                                         kwlist2, &PyGtkFileChooserDialog_Type,
					 &dialog)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "Usage: one of:\n"
			    "  gtk.FileChooserButton(title, backend=None)\n"
			    "  gtk.FileChooserButton(filechooserdialog)");
	    return -1;
	}
        pygobject_construct(self, "dialog", GTK_WIDGET(dialog->obj), NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkFileChooserBUtton object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_FILE_CHOOSER_BUTTON
%%
override gtk_icon_theme_get_icon_sizes kwargs
static PyObject *
_wrap_gtk_icon_theme_get_icon_sizes(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", NULL };
    const gchar *icon_name;
    gint *sizes;
    int i;
    PyObject *py_sizes;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:GtkIconTheme.get_icon_sizes",
				     kwlist, &icon_name))
        return NULL;

    sizes = gtk_icon_theme_get_icon_sizes(GTK_ICON_THEME(self->obj),
                                          icon_name);

    for (i = 0; sizes[i] != 0; i++) ;

    if ((py_sizes = PyTuple_New(i)) == NULL) {
        g_free(sizes);
        return NULL;
    }
    for (i = 0; sizes[i] != 0; i++)
        PyTuple_SET_ITEM(py_sizes, i, PyLong_FromLong(sizes[i]));

    g_free(sizes);
    return py_sizes;
}
%%
override gtk_image_get_icon_name noargs
static PyObject *
_wrap_gtk_image_get_icon_name(PyGObject *self)
{
    gchar *icon_name = NULL;
    GtkIconSize size = GTK_ICON_SIZE_INVALID;

    gtk_image_get_icon_name(GTK_IMAGE(self->obj),
                            (G_CONST_RETURN gchar **)&icon_name, &size);

    return Py_BuildValue("(sN)", icon_name,
                         pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size));
}
%%
override gtk_message_dialog_format_secondary_text kwargs
static PyObject *
_wrap_gtk_message_dialog_format_secondary_text(PyGObject *self, PyObject *args,
                                               PyObject *kwargs)
{
    static char *kwlist[] = { "message_format", NULL };
    gchar *message_format = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|z:GtkMessageDialog.format_secondary_text",
                                     kwlist, &message_format))
        return NULL;

    if (message_format)
        gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(self->obj),
                                                 "%s", message_format);
    else
        gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(self->obj),
                                                 NULL);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_message_dialog_format_secondary_markup kwargs
static PyObject *
_wrap_gtk_message_dialog_format_secondary_markup(PyGObject *self, PyObject *args,
                                               PyObject *kwargs)
{
    static char *kwlist[] = { "message_format", NULL };
    gchar *message_format = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|z:GtkMessageDialog.format_secondary_markup",
                                     kwlist, &message_format))
        return NULL;

    if (message_format)
        gtk_message_dialog_format_secondary_markup(GTK_MESSAGE_DIALOG(self->obj),
                                                   "%s", message_format);
    else
        gtk_message_dialog_format_secondary_markup(GTK_MESSAGE_DIALOG(self->obj),
                                                   NULL);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_target_list_add_text_targets kwargs
static PyObject *
_wrap_gtk_target_list_add_text_targets(PyGObject *self, PyObject *args,
                                       PyObject *kwargs)
{
    static char *kwlist[] = { "list", "info", NULL };
    PyObject *list = NULL;
    guint info = 0;
    GtkTargetList *targets;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|Oi:gtk.target_list_add_text_targets",
                                     kwlist, &list, &info)) {
        return NULL;
    }
    if (!list || list == Py_None) {
        targets = gtk_target_list_new(NULL, 0);
    } else if (!(targets = pygtk_target_list_from_sequence(list)))
        return NULL;

    gtk_target_list_add_text_targets(targets, info);
    list = pygtk_target_list_to_list(targets);
    gtk_target_list_unref(targets);
    return list;
}
%%
override gtk_target_list_add_image_targets kwargs
static PyObject *
_wrap_gtk_target_list_add_image_targets(PyGObject *self, PyObject *args,
                                       PyObject *kwargs)
{
    static char *kwlist[] = { "list", "info", "writable", NULL };
    PyObject *list = NULL;
    guint info = 0;
    gboolean writable = FALSE;
    GtkTargetList *targets;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|Oii:gtk.target_list_add_text_targets",
                                     kwlist, &list, &info, &writable)) {
        return NULL;
    }
    if (!list || list == Py_None) {
        targets = gtk_target_list_new(NULL, 0);
    } else if (!(targets = pygtk_target_list_from_sequence(list)))
        return NULL;

    gtk_target_list_add_image_targets(targets, info, writable);
    list = pygtk_target_list_to_list(targets);
    gtk_target_list_unref(targets);
    return list;
}
%%
override gtk_target_list_add_uri_targets kwargs
static PyObject *
_wrap_gtk_target_list_add_uri_targets(PyGObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "list", "info", NULL };
    PyObject *list = NULL;
    guint info = 0;
    GtkTargetList *targets;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|Oi:gtk.target_list_add_text_targets",
                                     kwlist, &list, &info)) {
        return NULL;
    }
    if (!list || list == Py_None) {
        targets = gtk_target_list_new(NULL, 0);
    } else if (!(targets = pygtk_target_list_from_sequence(list)))
        return NULL;

    gtk_target_list_add_uri_targets(targets, info);
    list = pygtk_target_list_to_list(targets);
    gtk_target_list_unref(targets);
    return list;
}
%%
override gtk_about_dialog_set_email_hook kwargs
static void
pygtk_about_dialog_link_hook_marshal(GtkAboutDialog *about,
                                         const gchar *link,
                                         gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_about, *retobj;
 
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
 
    py_about = pygobject_new((GObject *)about);

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NsO)", py_about,
                                     link, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(Ns)", py_about, link);
    }

    if (!retobj)
	PyErr_Print();
 
    Py_XDECREF(retobj);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_about_dialog_set_email_hook(PyGObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", NULL };
    PyObject *pyfunc = NULL, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:GtkAboutDialog.set_email_hook",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;

    if (pyfunc == NULL || pyfunc == Py_None) {
        gtk_about_dialog_set_email_hook(NULL, NULL, NULL);
    } else if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);

        gtk_about_dialog_set_email_hook(
            pygtk_about_dialog_link_hook_marshal,
            cunote,
            pygtk_custom_destroy_notify);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_about_dialog_set_url_hook kwargs
static PyObject *
_wrap_gtk_about_dialog_set_url_hook(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", NULL};
    PyObject *pyfunc = NULL, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:GtkAboutDialog.set_url_hook",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;

    if (pyfunc == NULL || pyfunc == Py_None) {
        gtk_about_dialog_set_url_hook(NULL, NULL, NULL);
    } else if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);

        gtk_about_dialog_set_url_hook(
            pygtk_about_dialog_link_hook_marshal,
            cunote,
            pygtk_custom_destroy_notify);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override GtkCellRenderer__proxy_do_get_size
static void
_wrap_GtkCellRenderer__proxy_do_get_size (GtkCellRenderer *cell,
                                          GtkWidget       *widget,
                                          GdkRectangle    *cell_area,
                                          gint            *x_offset,
                                          gint            *y_offset,
                                          gint            *width,
                                          gint            *height)
{
    PyGILState_STATE state;
    PyObject *self, *py_ret, *py_widget, *py_cell_area;
    gint my_x, my_y, my_width, my_height;

    state = pyg_gil_state_ensure();
    self = pygobject_new((GObject *)cell);
    py_widget = pygobject_new((GObject *)widget);
    py_cell_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, cell_area, TRUE, TRUE);

    py_ret = PyObject_CallMethod(self, "do_get_size", "OO",
				 py_widget, py_cell_area);
    if (!py_ret) {
	PyErr_Print();
	Py_DECREF(self);
	Py_DECREF(py_widget);
	Py_DECREF(py_cell_area);
	pyg_gil_state_release(state);
	return;
    }
    Py_DECREF(self);
    Py_DECREF(py_widget);
    Py_DECREF(py_cell_area);

    if (!PyArg_ParseTuple(py_ret, "iiii",
			  &my_x, &my_y, &my_width, &my_height)) {
	PyErr_Print();
	Py_DECREF(py_ret);
	pyg_gil_state_release(state);
	return;
    }
    Py_DECREF(py_ret);

    pyg_gil_state_release(state);

    /* success */
    if (x_offset)
	*x_offset = my_x;
    if (y_offset)
	*y_offset = my_y;
    if (width)
	*width = my_width;
    if (height)
	*height = my_height;
}
%%
override GtkCellRenderer__do_get_size kwargs
static PyObject *
_wrap_GtkCellRenderer__do_get_size(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "widget", "cell_area", NULL };
    PyGObject *self, *widget;
    PyObject *py_cell_area = Py_None;
    gint x, y, width, height;
    GdkRectangle cell_area, *cell_area_ptr;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!|O:GtkCellRenderer.do_get_size", kwlist,
                                     &PyGtkCellRenderer_Type, &self,
                                     &PyGtkWidget_Type, &widget,
                                     &py_cell_area))
        return NULL;

    if (py_cell_area == Py_None) {
	cell_area_ptr = NULL;
    }
    else {
	if (!pygdk_rectangle_from_pyobject(py_cell_area, &cell_area))
	    return NULL;
	cell_area_ptr = &cell_area;
    }

    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CELL_RENDERER_CLASS(klass)->get_size)
        GTK_CELL_RENDERER_CLASS(klass)->get_size(GTK_CELL_RENDERER(self->obj),
                                                 GTK_WIDGET(widget->obj),
                                                 cell_area_ptr,
                                                 &x, &y, &width, &height);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method GtkContainer.get_child_property not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    
    return Py_BuildValue("(iiii)", x, y, width, height);
}


%%
override GtkCellLayout__proxy_do_set_cell_data_func

typedef struct {
    GtkCellLayoutDataFunc  func;
    gpointer               func_data;
    GDestroyNotify         destroy;
} PyGtkCellLayoutDataFuncData;

static void
_wrap_GtkCellLayoutDataFunc_destroy(PyObject *arg)
{
    PyGtkCellLayoutDataFuncData *data = PyCapsule_GetPointer(arg, NULL);
    data->destroy(data->func_data);
    g_free(data);
}

static PyObject *
_wrap_GtkCellLayoutDataFunc(PyObject *self, PyObject *args)
{
    PyObject *py_cell_layout;
    PyObject *py_cell;
    PyObject *py_tree_model;
    PyObject *py_iter;
    PyObject *py_data;
    PyGtkCellLayoutDataFuncData *data;

    if (!PyArg_ParseTuple(args, "O!O!O!OO!",
                          &PyGtkCellLayout_Type, &py_cell_layout,
                          &PyGtkCellRenderer_Type, &py_cell,
                          &PyGtkTreeModel_Type, &py_tree_model,
                          &py_iter,
                          &PyCapsule_Type, &py_data))
        return NULL;
    if (!pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER)) {
        PyErr_SetString(PyExc_TypeError, "4th argument must be a gtk.TreeIter");
        return NULL;
    }

    data = PyCapsule_GetPointer(py_data, NULL);
    data->func(GTK_CELL_LAYOUT(pygobject_get(py_cell_layout)),
               GTK_CELL_RENDERER(pygobject_get(py_cell)),
               GTK_TREE_MODEL(pygobject_get(py_tree_model)),
               pyg_boxed_get(py_iter, GtkTreeIter),
               data->func_data);
    Py_INCREF(Py_None);
    return Py_None;
}

static void
_wrap_GtkCellLayout__proxy_do_set_cell_data_func (
    GtkCellLayout         *cell_layout,
    GtkCellRenderer       *cell,
    GtkCellLayoutDataFunc  func,
    gpointer               func_data,
    GDestroyNotify         destroy)
{
    PyGILState_STATE state;
    PyObject *self, *py_ret, *py_cell, *py_func, *py_func_data;
    PyMethodDef pyfunc_def = { NULL, (PyCFunction)_wrap_GtkCellLayoutDataFunc,
                               METH_VARARGS|METH_KEYWORDS };
    PyGtkCellLayoutDataFuncData *data;

    state = pyg_gil_state_ensure();
    self = pygobject_new((GObject *)cell);
    py_cell = pygobject_new((GObject *)cell);
    py_func = PyCFunction_NewEx(&pyfunc_def, NULL, NULL);
    data = g_new(PyGtkCellLayoutDataFuncData, 1);
    data->func = func;
    data->func_data = func_data;
    data->destroy = destroy;
    py_func_data = PyCapsule_New(data, NULL, _wrap_GtkCellLayoutDataFunc_destroy);

    py_ret = PyObject_CallMethod(self, "do_set_cell_data_func", "NNNN",
                                 self, py_cell, py_func, py_func_data);
    if (!py_ret)
	PyErr_Print();
    Py_DECREF(self);
    Py_XDECREF(py_ret);
    pyg_gil_state_release(state);
}
%%
override gtk_dialog_set_alternative_button_order kwargs
static PyObject *
_wrap_gtk_dialog_set_alternative_button_order(PyGObject *self, PyObject *args,
                                              PyObject *kwargs)
{
    static char *kwlist[] = { "new_order", NULL };
    gint *new_order, n_params;
    PyObject *py_new_order;
    int i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkDialog.set_alternative_button_order",
                                     kwlist, &py_new_order))
        return NULL;

    n_params = PySequence_Size(py_new_order);
    if (!PySequence_Check(py_new_order) || n_params < 1) {
        PyErr_SetString(PyExc_TypeError,
                        "new_order must be a sequence with"
                        "at least one response id int");
        return NULL;
    }
    new_order = (gint *)g_new0(gint, n_params);
    for (i = 0; i < n_params; i++) {
        PyObject *item = PySequence_GetItem(py_new_order, i);

        if (!PyLong_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "each new_order item must be an integer");
            g_free(new_order);
            Py_XDECREF(item);
            return NULL;
        }
        new_order[i] = PyLong_AsLong(item);
        Py_DECREF(item);
    }
    gtk_dialog_set_alternative_button_order_from_array(GTK_DIALOG(self->obj),
                                                       n_params, new_order);
    g_free(new_order);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_icon_info_free noargs
static PyObject *
_wrap_gtk_icon_info_free(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.IconInfo.free should not be used") < 0)
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_icon_source_free noargs
static PyObject *
_wrap_gtk_icon_source_free(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.IconSource.free should not be used") < 0)
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_requisition_free noargs
static PyObject *
_wrap_gtk_requisition_free(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Requisition.free should not be used") < 0)
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_iter_free noargs
static PyObject *
_wrap_gtk_tree_iter_free(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.TreeIter.free should not be used") < 0)
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_row_reference_free noargs
static PyObject *
_wrap_gtk_tree_row_reference_free(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.TreeRowReference.free should not be used") < 0)
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_border_free noargs
static PyObject *
_wrap_gtk_border_free(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Border.free should not be used") < 0)
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_request_image kwargs
static void
clipboard_request_image_cb(GtkClipboard *clipboard,
			  GdkPixbuf *pixbuf,
			  gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret, *py_image;

    if (pixbuf) {
        py_image = pygobject_new((GObject *)pixbuf);
    } else {
        py_image = Py_None;
        Py_INCREF(Py_None);
    }

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)clipboard),
                         py_image,
			 PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF((PyObject *)user_data);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_request_image(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "callback", "user_data", NULL };
    PyObject *callback, *data, *user_data = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkClipboard.request_image",
				     kwlist, &callback, &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_image(GTK_CLIPBOARD(self->obj),
			       clipboard_request_image_cb,
			       (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gtk_print_context_get_cairo_context noargs
static PyObject *
_wrap_gtk_print_context_get_cairo_context(PyGObject *self)
{
    cairo_t *ret;

    ret = gtk_print_context_get_cairo_context(GTK_PRINT_CONTEXT(self->obj));

    cairo_reference(ret);
    return PycairoContext_FromContext(ret, &PyGdkCairoContext_Type, NULL);
}
%%
override gtk_assistant_set_forward_page_func kwargs
static gint
pygtk_assistant_set_forward_page_func_cb(gint current_page,
                                         gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    gint ret = current_page;
    PyObject *retobj;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(iO)",
                                     current_page, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(i)", current_page);
    }

    if (retobj != NULL) {
        ret = PyLong_AsLong(retobj);
        Py_DECREF(retobj);
    } else {
        PyErr_Print();
    }
  
    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_assistant_set_forward_page_func(PyGObject *self, PyObject *args,
                                          PyObject *kwargs)
{
    static char *kwlist[] = { "page_func", "data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                          "O|O:GtkAssistant.set_forward_page_func",
                          kwlist, &pyfunc, &pyarg))
        return NULL;

    if (pyfunc != Py_None  && !PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "page_func must be a callable object");
        return NULL;
    }

    if (pyfunc == Py_None) {
        gtk_assistant_set_forward_page_func(GTK_ASSISTANT(self->obj),
                                            NULL, NULL, NULL);
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);
 
        gtk_assistant_set_forward_page_func(GTK_ASSISTANT(self->obj),
                                            pygtk_assistant_set_forward_page_func_cb,
                                            cunote, pygtk_custom_destroy_notify);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_request_rich_text kwargs
static void
clipboard_request_rich_text_cb(GtkClipboard *clipboard,
                               GdkAtom format,
                               const guint8 *text,
                               gsize length,
                               gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret, *py_format, *py_text, *data;
    gchar *name;

    data = (PyObject *) user_data;

    if (text) {
        py_text = PyUnicode_FromString((char *) text);
    } else {
        py_text = Py_None;
        Py_INCREF(Py_None);
    }

    name = gdk_atom_name(format);
    py_format = PyUnicode_FromString(name);
    g_free(name);
 
    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem(data, 0);
    args = Py_BuildValue("(NNNiO)",
			 pygobject_new((GObject *)clipboard),
                         py_format, py_text, length,
			 PyTuple_GetItem(data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF((PyObject *)user_data);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_request_rich_text(PyGObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", "callback", "user_data", NULL };
    PyObject *callback, *data, *user_data = Py_None;
    GtkTextBuffer *buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!O|O:GtkClipboard.request_rich_text",
				     kwlist, &PyGtkTextBuffer_Type, &buffer,
                                     &callback, &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_rich_text(GTK_CLIPBOARD(self->obj), buffer,
                                    clipboard_request_rich_text_cb,
                                    (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_wait_for_rich_text kwargs
static PyObject *
_wrap_gtk_clipboard_wait_for_rich_text(PyGObject *self, PyObject *args,
                                       PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", NULL };
    GtkTextBuffer *buffer;
    GdkAtom format;
    gchar *name;
    gsize length;
    guint8 *ret;
 
     
    if (!PyArg_ParseTupleAndKeywords(args,kwargs,
				     "O:GtkClipboard.wait_for_rich_text",
                                     kwlist, &PyGtkTextBuffer_Type, &buffer))
        return NULL;

    ret = gtk_clipboard_wait_for_rich_text(GTK_CLIPBOARD(self->obj),
                                           buffer, &format, &length);
     
    if (ret) {
        PyObject *py_ret;
        name = gdk_atom_name(format);
        py_ret = Py_BuildValue("(s#s)", ret, (Py_ssize_t) length, name);
        g_free(ret);
        g_free(name);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_link_button_set_uri_hook kwargs
static void
pygtk_link_button_set_uri_hook_cb(GtkLinkButton *button,
                                  const gchar *link,
                                  gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *retobj;
    g_assert(cunote->func);
 
    state = pyg_gil_state_ensure();
  
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NsO)",
                                     pygobject_new((GObject *)button),
                                     link, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(Ns)",
                                     pygobject_new((GObject *)button), link);
    }
 
    if (retobj == NULL)
        PyErr_Print();

    Py_XDECREF(retobj);
  
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_link_button_set_uri_hook(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                          "O|O:gtk.link_button_set_uri_hook",
                          kwlist, &pyfunc, &pyarg))
        return NULL;
  
    if (pyfunc != Py_None  && !PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object or None");
        return NULL;
    }

    if (pyfunc == Py_None) {
        gtk_link_button_set_uri_hook(NULL, NULL, NULL);
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);
 
        gtk_link_button_set_uri_hook(pygtk_link_button_set_uri_hook_cb,
                                     cunote, pygtk_custom_destroy_notify);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_print_settings_foreach kwargs
static void
pygtk_print_settings_foreach_cb(const gchar *key,
                                const gchar *value,
                                gpointer data)
{
    PyGILState_STATE state;
    PyObject *retobj;
    PyGtkCustomNotify *cunote = data;
  
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
  
    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(ssO)", key, value,
                                     cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(ss)", key, value);
 
    if (retobj == NULL)
        PyErr_Print();

    Py_XDECREF(retobj);
  
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_print_settings_foreach(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "func", "user_data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:gtk.PrintSettings.foreach",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;
  
    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }

    cunote.func = pyfunc;
    cunote.data = pyarg;
 
    gtk_print_settings_foreach(GTK_PRINT_SETTINGS(self->obj),
                               pygtk_print_settings_foreach_cb, &cunote);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_print_settings_get_page_ranges noargs
static PyObject *
_wrap_gtk_print_settings_get_page_ranges(PyGObject *self)
{
    GtkPageRange *ranges;
    PyObject *py_ranges;
    gint n_ranges, i;

    ranges = gtk_print_settings_get_page_ranges(GTK_PRINT_SETTINGS(self->obj),
                                                &n_ranges);

    py_ranges = PyList_New(n_ranges);

    for (i = 0; i < n_ranges; i++)
        PyList_SetItem(py_ranges, i,
                       Py_BuildValue("(ii)", ranges[i].start, ranges[i].end));
    g_free(ranges);
    return py_ranges;
}
%%
override gtk_print_settings_set_page_ranges kwargs
static PyObject *
_wrap_gtk_print_settings_set_page_ranges(PyGObject *self, PyObject *args,
                                         PyObject *kwargs)
{
    static char *kwlist[] = { "page_ranges", NULL };
    PyObject *py_ranges;
    gint n_ranges = 0, i;
    GtkPageRange *ranges = NULL;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:gtk.PrintSettings.set_page_ranges",
                                     kwlist, &py_ranges))
        return NULL;

    if (!PySequence_Check(py_ranges)) {
        PyErr_SetString(PyExc_TypeError,
                        "page_ranges must be a sequence of 2-tuples");
        return NULL;
    }

    n_ranges = PySequence_Size(py_ranges);
    ranges = g_new0(GtkPageRange, n_ranges);
    for (i = 0; i < n_ranges; i++) {
        PyObject *range = PySequence_GetItem(py_ranges, i);

        if (!PyTuple_Check(range)) {
            PyErr_SetString(PyExc_TypeError,
                            "Each page range must be a 2-tuple of start and end page numbers");
            g_free(ranges);
            return NULL;
        }
        if (!PyArg_ParseTuple(range,
                              "ii;Each page range must be a 2-tuple of start and end page numbers",
                              &ranges[i].start, &ranges[i].end)) {
            Py_DECREF(range);
            g_free(ranges);
            return NULL;
        }
        Py_DECREF(range);
    }
    gtk_print_settings_set_page_ranges(GTK_PRINT_SETTINGS(self->obj),
                                       ranges, n_ranges);
    g_free(ranges);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_recent_chooser_get_items noargs
static PyObject *
_wrap_gtk_recent_chooser_get_items(PyGObject *self)
{
    GList *items;
    GtkRecentInfo *info;
    PyObject *py_items;
    guint count, i;

    items = gtk_recent_chooser_get_items(GTK_RECENT_CHOOSER(self->obj));
    count = g_list_length(items);
    py_items = PyList_New(count);
    for (i = 0;  i < count; i++) {
        info = g_list_nth_data(items, i);
        PyList_SetItem(py_items, i,
                       pyg_boxed_new(GTK_TYPE_RECENT_INFO, info, TRUE, TRUE));
    }
    g_list_foreach(items, (GFunc) gtk_recent_info_unref, NULL);
    g_list_free(items);

    return py_items;
}
%%
override gtk_recent_chooser_get_uris noargs
static PyObject *
_wrap_gtk_recent_chooser_get_uris(PyGObject *self)
{
    gchar **uris;
    PyObject *py_uris;
    gsize length, i;

    uris = gtk_recent_chooser_get_uris(GTK_RECENT_CHOOSER(self->obj),
                                        &length);
    if (!uris)
        length = 0;
    py_uris = PyList_New(length);
    for (i = 0; i < length; i++)
        PyList_SetItem(py_uris, i, PyUnicode_FromString(uris[i]));
    g_strfreev(uris);

    return py_uris;
}
%%
override gtk_recent_chooser_dialog_new  kwargs
static int
_wrap_gtk_recent_chooser_dialog_new(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    gchar *title = NULL;
    PyGObject *py_window = NULL, *py_manager = NULL;
    PyObject *py_buttons = Py_None;
    int len, i;
    GtkWindow *parent;
    GtkRecentManager *manager;
    
    static char *kwlist[] = { "title", "parent", "manager", "buttons", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zOOO:gtk.RecentChooserDialog", kwlist,
                                     &title, &py_window, &py_manager,
                                     &py_buttons))
        return -1;

    if (py_window == NULL || (PyObject*)py_window == Py_None)
	parent = NULL;
    else if (pygobject_check(py_window, &PyGtkWindow_Type))
	parent = GTK_WINDOW(py_window->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "parent must be a GtkWindow or None");
        return -1;
    }

    if (py_manager == NULL || (PyObject*)py_manager == Py_None)
	manager = NULL;
    else if (pygobject_check(py_manager, &PyGtkRecentManager_Type))
	manager = GTK_RECENT_MANAGER(py_manager->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "manager must be a GtkRecentManager or None");
        return -1;
    }

    if (py_buttons == Py_None)
        len = 0;
    else if (PySequence_Check(py_buttons))
        len = PySequence_Size(py_buttons);
    else {
        PyErr_SetString(PyExc_TypeError, "buttons must be a sequence containing text/response pairs or None");
        return -1;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }

    if (pygobject_construct(self, "recent-manager", manager, NULL)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkDialog object");
        return -1;
    }

  if (title)
    gtk_window_set_title (GTK_WINDOW (self->obj), title);

  if (parent)
    gtk_window_set_transient_for (GTK_WINDOW (self->obj), parent);

  for (i = 0; i < len; i += 2) {
      PyObject *text = PySequence_GetItem(py_buttons, i);
      PyObject *id = PySequence_GetItem(py_buttons, i + 1);
      if (!PyUnicode_Check(text)) {
          gtk_object_destroy(GTK_OBJECT(self->obj));
          self->obj = NULL;
          PyErr_SetString(PyExc_RuntimeError,
                          "first member of each text/response id pair "
                          "must be a string");
          Py_DECREF(text);
          Py_DECREF(id);
          return -1;
      }
      if (!PyLong_Check(id)) {
          gtk_object_destroy(GTK_OBJECT(self->obj));
          self->obj = NULL;
          PyErr_SetString(PyExc_RuntimeError,
                          "second member of each text/response id pair "
                          "must be a number");
          Py_DECREF(text);
          Py_DECREF(id);
          return -1;
      }
      gtk_dialog_add_button(GTK_DIALOG(self->obj), PyUnicode_AsUTF8(text),
                            PyLong_AsLong(id));
      Py_DECREF(text);
      Py_DECREF(id);
  }
    
  return 0;
}
%%
new-constructor GTK_TYPE_RECENT_CHOOSER_DIALOG
%%
override gtk_recent_chooser_list_filters noargs
static PyObject *
_wrap_gtk_recent_chooser_list_filters(PyGObject *self)
{
    GSList *filters;
    GtkRecentFilter *filter;
    PyObject *py_filters;
    guint count, i;

    filters = gtk_recent_chooser_list_filters(GTK_RECENT_CHOOSER(self->obj));
    count = g_slist_length(filters);
    py_filters = PyList_New(count);
    for (i = 0; i < count; i++) {
        filter = g_slist_nth_data(filters, i);
        PyList_SetItem(py_filters, i, pygobject_new((GObject*)filter));
    }
    g_slist_free(filters);

    return py_filters;
}
%%
override gtk_recent_chooser_set_sort_func kwargs
static gint
pygtk_recent_chooser_set_sort_func_cb(GtkRecentInfo *a,
                                      GtkRecentInfo *b,
                                      gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_a, *py_b, *retobj;
    gint ret = -1;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_a = pyg_boxed_new(GTK_TYPE_RECENT_INFO, a, TRUE, TRUE);
    py_b = pyg_boxed_new(GTK_TYPE_RECENT_INFO, b, TRUE, TRUE);
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NNO)",
                                     py_a, py_b, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NN)", py_a, py_b);
    }

    if (retobj != NULL) {
        ret = PyLong_AsLong(retobj);
        Py_DECREF(retobj);
    } else {
        PyErr_Print();
    }

    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_recent_chooser_set_sort_func(PyGObject *self, PyObject *args,
                                          PyObject *kwargs)
{
    static char *kwlist[] = { "sort_func", "sort_data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkRecentChooser.set_sort_func",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "sort_func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);
 
    gtk_recent_chooser_set_sort_func(GTK_RECENT_CHOOSER(self->obj),
                                        pygtk_recent_chooser_set_sort_func_cb,
                                        cunote, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_recent_info_get_applications noargs
static PyObject *
_wrap_gtk_recent_info_get_applications(PyGObject *self)
{
    gchar **apps;
    PyObject *py_apps;
    gsize length, i;

    apps = gtk_recent_info_get_applications(pyg_boxed_get(self, GtkRecentInfo),
                                            &length);
    if (!apps)
        length = 0;
    py_apps = PyList_New(length);
    for (i = 0; i < length; i++)
        PyList_SetItem(py_apps, i, PyUnicode_FromString(apps[i]));
    g_strfreev(apps);

    return py_apps;
}
%%
override gtk_recent_info_get_groups noargs
static PyObject *
_wrap_gtk_recent_info_get_groups(PyGObject *self)
{
    gchar **groups;
    PyObject *py_groups;
    gsize length, i;

    groups = gtk_recent_info_get_groups(pyg_boxed_get(self, GtkRecentInfo),
                                        &length);
    if (!groups)
        length = 0;
    py_groups = PyList_New(length);
    for (i = 0; i < length; i++)
        PyList_SetItem(py_groups, i, PyUnicode_FromString(groups[i]));
    g_strfreev(groups);

    return py_groups;
}
%%
override gtk_recent_info_get_application_info kwargs
static PyObject *
_wrap_gtk_recent_info_get_application_info(PyGObject *self, PyObject *args,
                                           PyObject *kwargs)
{
    static char *kwlist[] = { "app_name", NULL };
    gchar *app_name;
    const gchar *app_exec = NULL;
    gboolean ret;
    PyObject *py_ret;
    guint count = 0;
    time_t time_;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s:GtkRecentInfo.get_application_info",
                                     kwlist, &app_name))
        return NULL;

    ret = gtk_recent_info_get_application_info(pyg_boxed_get(self,
                                                             GtkRecentInfo),
                                               app_name, &app_exec, &count,
                                               &time_);
    if (ret) {
        py_ret = Py_BuildValue("(sii)", app_exec, count, time_);
        /* Note that we mustn't free 'app_exec' even though it's not
         * 'const'.  See bug #585458. */
    } else {
        py_ret = Py_None;
    }
    return py_ret;
}
%%
override gtk_size_group_get_widgets noargs
static PyObject *
_wrap_gtk_size_group_get_widgets(PyGObject *self)
{
    GSList *widgets;
    GtkWidget *widget;
    PyObject *py_widgets;
    guint count, i;

    widgets = gtk_size_group_get_widgets(GTK_SIZE_GROUP(self->obj));
    count = g_slist_length(widgets);
    py_widgets = PyList_New(count);
    for (i = 0; i < count; i++) {
        widget = g_slist_nth_data(widgets, i);
        PyList_SetItem(py_widgets, i, pygobject_new((GObject*)widget));
    }

    return py_widgets;
}
%%
override gtk_recent_filter_add_custom kwargs
static gboolean
pygtk_recent_filter_add_custom_cb(const GtkRecentFilterInfo *info,
                                  gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_info, *retobj;
    gboolean ret = TRUE;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_info = PyDict_New();

    if (info->contains & GTK_RECENT_FILTER_URI)
        PyDict_SetItemString(py_info, "uri", PyUnicode_FromString(info->uri));

    if (info->contains & GTK_RECENT_FILTER_DISPLAY_NAME)
        PyDict_SetItemString(py_info, "display_name",
                             PyUnicode_FromString(info->display_name));

    if (info->contains & GTK_RECENT_FILTER_MIME_TYPE)
        PyDict_SetItemString(py_info, "mime_type",
                             PyUnicode_FromString(info->mime_type));

    if (info->contains & GTK_RECENT_FILTER_APPLICATION) {
        gchar **apps = (gchar **)info->applications;
        PyObject *applications = PyList_New(0);
        if (apps) {
            while (*apps) {
                PyList_Append(applications, PyUnicode_FromString(*apps));
                apps++;
            }
        }
        PyDict_SetItemString(py_info, "applications", applications);
    }

    if (info->contains & GTK_RECENT_FILTER_GROUP) {
        gchar **grps = (gchar **)info->groups;
        PyObject *groups = PyList_New(0);
        if (grps) {
            while (*grps) {
                PyList_Append(groups, PyUnicode_FromString(*grps));
                grps++;
            }
        }
        PyDict_SetItemString(py_info, "groups", groups);
    }

    if (info->contains & GTK_RECENT_FILTER_AGE)
        PyDict_SetItemString(py_info, "age", PyLong_FromLong(info->age));
    
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NO)", py_info,
                                      cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(N)", py_info);
    }

    if (retobj != NULL) {
        ret = PyLong_AsLong(retobj);
        Py_DECREF(retobj);
    } else {
        PyErr_Print();
    }

    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_recent_filter_add_custom(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "needed", "func", "data", NULL };
    PyObject *pyneeded, *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
    GtkRecentFilterFlags needed;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|O:GtkRecentFilter.add_custom",
                                     kwlist, &pyneeded, &pyfunc, &pyarg))
        return NULL;

    if (pyg_flags_get_value(GTK_TYPE_RECENT_FILTER_FLAGS, pyneeded,
                            (gint *)&needed))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);
 
    gtk_recent_filter_add_custom(GTK_RECENT_FILTER(self->obj), needed,
                                 pygtk_recent_filter_add_custom_cb,
                                 cunote, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_recent_filter_filter kwargs
static PyObject*
_wrap_gtk_recent_filter_filter(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "filter_info", NULL };
    GtkRecentFilterInfo info;
    PyObject *py_info, *py_ret = Py_False, *item;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkRecentFilter.filter", kwlist,
                                     &py_info))
        return NULL;

    if (!PyDict_Check(py_info)) {
        PyErr_SetString(PyExc_TypeError, "filter_info must be a mapping");
        return NULL;
    }

    if ((item = PyDict_GetItemString(py_info, "uri"))) {
        if (!PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "filter_info uri must be a string");
            return NULL;
        }
        info.uri = PyUnicode_AsUTF8(item);
        info.contains |= GTK_RECENT_FILTER_URI;
    } else {
        info.uri = NULL;
    }

    if ((item = PyDict_GetItemString(py_info, "mime_type"))) {
        if (!PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "filter_info mime_type must be a string");
            return NULL;
        }
        info.mime_type = PyUnicode_AsUTF8(item);
        info.contains |= GTK_RECENT_FILTER_MIME_TYPE;
    } else {
        info.mime_type = NULL;
    }

    if ((item = PyDict_GetItemString(py_info, "display_name"))) {
        if (!PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "filter_info display_name must be a string");
            return NULL;
        }
        info.display_name = PyUnicode_AsUTF8(item);
        info.contains |= GTK_RECENT_FILTER_DISPLAY_NAME;
    } else {
        info.display_name = NULL;
    }

    if ((item = PyDict_GetItemString(py_info, "applications"))) {
        gint size, i;
        if (!PySequence_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "filter_info applications must be a sequence of strings");
            return NULL;
        }
        size = PySequence_Size(item);
        info.applications = (const gchar**)g_new0(gchar*, size + 1);
        for (i = 0; i < size; i++) {
            PyObject *app = PySequence_GetItem(item, i);
            if (!PyUnicode_Check(app)) {
                PyErr_SetString(PyExc_TypeError,
                                "filter_info applications must be a sequence of strings");
                return NULL;
            }
            info.applications[i] = PyUnicode_AsUTF8(app);
            Py_DECREF(app);
        }
        info.contains |= GTK_RECENT_FILTER_APPLICATION;
    } else {
        info.applications = NULL;
    }

    if ((item = PyDict_GetItemString(py_info, "groups"))) {
        gint size, i;
        if (!PySequence_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "filter_info groups must be a sequence of strings");
            return NULL;
        }
        size = PySequence_Size(item);
        info.groups = (const gchar**)g_new0(gchar*, size + 1);
        for (i = 0; i < size; i++) {
            PyObject *grp = PySequence_GetItem(item, i);
            if (!PyUnicode_Check(grp)) {
                PyErr_SetString(PyExc_TypeError,
                                "filter_info groups must be a sequence of strings");
                return NULL;
            }
            info.groups[i] = PyUnicode_AsUTF8(grp);
            Py_DECREF(grp);
        }
        info.contains |= GTK_RECENT_FILTER_GROUP;
    } else {
        info.groups = NULL;
    }

    if ((item = PyDict_GetItemString(py_info, "age"))) {
        if (!PyLong_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "filter_info age must be an int");
            return NULL;
        }
        info.age = PyLong_AsLong(item);
        info.contains |= GTK_RECENT_FILTER_AGE;
    } else {
        info.age = -1;
    }

    if (gtk_recent_filter_filter(GTK_RECENT_FILTER(self->obj), &info))
        py_ret = Py_True;

    if (info.applications)
        g_free(info.applications);
    if (info.groups)
        g_free(info.groups);

    Py_INCREF(py_ret);
    return py_ret;
}
%%
override gtk_recent_manager_add_full kwargs
static PyObject*
_wrap_gtk_recent_manager_add_full(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "uri", "recent_data", NULL };
    PyObject *py_data, *item, *py_ret = Py_False;
    gchar *uri;
    GtkRecentData recent_data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "sO:GtkRecentManager.add_full", kwlist,
                                     &uri, &py_data))
        return NULL;

    if (!PyDict_Check(py_data)) {
        PyErr_SetString(PyExc_TypeError, "recent_data must be a mapping");
        return NULL;
    }

    if (!(item = PyDict_GetItemString(py_data, "mime_type"))
        || !PyUnicode_Check(item)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "recent_data must reference a 'mime_type' string value");
        return NULL;
    }
    recent_data.mime_type = PyUnicode_AsUTF8(item);

    if (!(item = PyDict_GetItemString(py_data, "app_name"))
        || !PyUnicode_Check(item)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "recent_data must reference a 'app_name' string value");
        return NULL;
    }
    recent_data.app_name = PyUnicode_AsUTF8(item);

    if (!(item = PyDict_GetItemString(py_data, "app_exec"))
        || !PyUnicode_Check(item)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "recent_data must reference a 'app_exec' string value");
        return NULL;
    }
    recent_data.app_exec = PyUnicode_AsUTF8(item);

    if ((item = PyDict_GetItemString(py_data, "display_name"))) {
        if (!PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "recent_data 'display_name' must reference a string");
            return NULL;
        }
        recent_data.display_name = PyUnicode_AsUTF8(item);
    } else {
        recent_data.display_name = NULL;
    }

    if ((item = PyDict_GetItemString(py_data, "description"))) {
        if (!PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "recent_data 'description' must reference a string");
            return NULL;
        }
        recent_data.description = PyUnicode_AsUTF8(item);
    } else {
        recent_data.description = NULL;
    }

    if ((item = PyDict_GetItemString(py_data, "is_private"))) {
        if (!PyBool_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "recent_data 'is_private' must reference a boolean");
            return NULL;
        }
        if (item == Py_True)
            recent_data.is_private = TRUE;
        else
            recent_data.is_private = FALSE;
    } else {
        recent_data.is_private = FALSE;
    }

    if ((item = PyDict_GetItemString(py_data, "groups"))) {
        gint size, i;
        if (!PySequence_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "recent_data 'groups' must reference a sequence of strings");
            return NULL;
        }
        size = PySequence_Size(item);
        recent_data.groups = (gchar**)g_new0(gchar*, size+1);
        for (i = 0; i < size; i++) {
            PyObject *group = PySequence_GetItem(item, i);
            if (!PyUnicode_Check(group)) {
                PyErr_SetString(PyExc_TypeError,
                                "recent_data 'groups' must reference a sequence of strings");
                g_free(recent_data.groups);
                Py_XDECREF(group);
                return NULL;
            }
            recent_data.groups[i] = PyUnicode_AsUTF8(group);
            Py_DECREF(group);
        }
    } else {
        recent_data.groups = NULL;
    }

    if (gtk_recent_manager_add_full(GTK_RECENT_MANAGER(self->obj), uri,
                                    &recent_data))
        py_ret = Py_True;

    if (recent_data.groups)
        g_free(recent_data.groups);

    Py_INCREF(py_ret);
    return py_ret;
}
%%
override gtk_recent_manager_get_items noargs
static PyObject *
_wrap_gtk_recent_manager_get_items(PyGObject *self)
{
    GtkRecentInfo *info;
    GList *items;
    PyObject *py_items;
    guint count, i;

    items = gtk_recent_manager_get_items(GTK_RECENT_MANAGER(self->obj));
    count = g_list_length(items);
    py_items = PyList_New(count);
    for (i = 0; i < count; i++) {
        info = g_list_nth_data(items, i);
        PyList_SetItem(py_items, i,
                       pyg_boxed_new(GTK_TYPE_RECENT_INFO, info, TRUE, TRUE));
    }
    g_list_foreach(items, (GFunc) gtk_recent_info_unref, NULL);
    g_list_free(items);

    return py_items;
}
%%
override gtk_status_icon_get_geometry noargs
static PyObject *
_wrap_gtk_status_icon_get_geometry(PyGObject *self)
{
    GdkScreen *screen;
    GdkRectangle rect;
    GtkOrientation orientation;
    gboolean ret;

    ret = gtk_status_icon_get_geometry(GTK_STATUS_ICON(self->obj),
                                       &screen, &rect, &orientation);
    if (ret) 
        return Py_BuildValue("(NNN)", pygobject_new((GObject*)screen),
                             pyg_boxed_new(GDK_TYPE_RECTANGLE, &rect,
                                           TRUE, TRUE),
                             pyg_enum_from_gtype(GTK_TYPE_ORIENTATION,
                                                 orientation));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_status_icon_position_menu args
static PyObject *
_wrap_gtk_status_icon_position_menu(PyGObject *self, PyObject *args)
{
    PyGObject *menu, *icon;
    gint x, y;
    gboolean push_in;

    if (!PyArg_ParseTuple(args,"O!O!:gtk.status_icon_position_menu",
                          &PyGtkMenu_Type, &menu,
                          &PyGtkStatusIcon_Type, &icon))
        return NULL;

    gtk_status_icon_position_menu(GTK_MENU(menu->obj), &x, &y, &push_in,
                                  (gpointer)icon->obj);
    return Py_BuildValue("(iii)", x, y, push_in);
}
%%
override gtk_targets_include_image kwargs
static PyObject *
_wrap_gtk_targets_include_image(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "writable", NULL };
    GdkAtom *targets;
    gint n_targets;
    gboolean writable;
    PyObject *py_targets, *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oi:gtk.targets_include_image",
                                     kwlist, &py_targets, &writable))
        return NULL;

    if (!(targets = pygdk_atom_vector_from_sequence(py_targets, &n_targets)))
        return NULL;

    if (gtk_targets_include_image(targets, n_targets, writable))
        py_ret = Py_True;
    else
        py_ret = Py_False;
    g_free(targets);
    return py_ret;
}
%%
override gtk_targets_include_text kwargs
static PyObject *
_wrap_gtk_targets_include_text(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "targets", NULL };
    GdkAtom *targets;
    gint n_targets;
    PyObject *py_targets, *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:gtk.targets_include_text",
                                     kwlist, &py_targets))
        return NULL;

    if (!(targets = pygdk_atom_vector_from_sequence(py_targets, &n_targets)))
        return NULL;

    if (gtk_targets_include_text(targets, n_targets))
        py_ret = Py_True;
    else
        py_ret = Py_False;
    g_free(targets);
    return py_ret;
}
%%
override gtk_targets_include_uri kwargs
static PyObject *
_wrap_gtk_targets_include_uri(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "targets", NULL };
    GdkAtom *targets;
    gint n_targets;
    PyObject *py_targets, *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:gtk.targets_include_uri",
                                     kwlist, &py_targets))
        return NULL;

    if (!(targets = pygdk_atom_vector_from_sequence(py_targets, &n_targets)))
        return NULL;

    if (gtk_targets_include_uri(targets, n_targets))
        py_ret = Py_True;
    else
        py_ret = Py_False;
    g_free(targets);
    return py_ret;
}
%%
override gtk_targets_include_rich_text kwargs
static PyObject *
_wrap_gtk_targets_include_rich_text(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "buffer", NULL };
    GdkAtom *targets;
    PyGObject *buffer;
    gint n_targets;
    PyObject *py_targets, *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO!:gtk.targets_include_rich_text",
                                     kwlist, &py_targets,
                                     &PyGtkTextBuffer_Type, &buffer))
        return NULL;

    if (!(targets = pygdk_atom_vector_from_sequence(py_targets, &n_targets)))
        return NULL;

    if (gtk_targets_include_rich_text(targets, n_targets,
                                      GTK_TEXT_BUFFER(buffer->obj)))
        py_ret = Py_True;
    else
        py_ret = Py_False;
    g_free(targets);
    return py_ret;
}
%%
override gtk_target_list_add_rich_text_targets kwargs
static PyObject *
_wrap_gtk_target_list_add_rich_text_targets(PyGObject *self, PyObject *args,
                                       PyObject *kwargs)
{
    static char *kwlist[] = { "list", "info", "deserializable", "buffer", NULL };
    PyObject *list = NULL;
    guint info = 0;
    GtkTargetList *targets;
    gboolean deserializable;
    PyGObject *buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OiiO!:gtk.target_list_add_rich_text_targets",
                                     kwlist, &list, &info, &deserializable,
                                     &PyGtkTextBuffer_Type, &buffer)) {
        return NULL;
    }
    if (!list || list == Py_None) {
        targets = gtk_target_list_new(NULL, 0);
    } else if (!(targets = pygtk_target_list_from_sequence(list)))
        return NULL;

    gtk_target_list_add_rich_text_targets(targets, info, deserializable,
                                          GTK_TEXT_BUFFER(buffer->obj));
    list = pygtk_target_list_to_list(targets);
    gtk_target_list_unref(targets);
    return list;
}
%%
override gtk_notebook_set_window_creation_hook kwargs
static GtkNotebook *
pygtk_notebook_set_window_creation_hook_cb(GtkNotebook *notebook,
                                           GtkWidget *page,
                                           gint x, gint y,
                                           gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_notebook, *py_page, *retobj;
    GtkNotebook *ret = NULL;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_notebook = pygobject_new((GObject*)notebook);
    py_page = pygobject_new((GObject*)page);
    
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NNiiO)", py_notebook,
                                     py_page, x, y, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NNii)", py_notebook,
                                     py_page, x, y);
    }

    if (retobj) {
        if (!pygobject_check((PyGObject*)retobj, &PyGtkNotebook_Type)) {
            PyErr_SetString(PyExc_TypeError,
                            "GtkNotebook window creation hook function return should be a GtkNotebook or None");
            PyErr_Print();
            ret = NULL;
        } else {
            ret = GTK_NOTEBOOK(pygobject_get(retobj));
        }
        Py_DECREF(retobj);
    } else {
        PyErr_Print();
        ret = NULL;
    }

    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_notebook_set_window_creation_hook(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:gtk.notebook_set_window_creation_hook",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);
 
    gtk_notebook_set_window_creation_hook(
        pygtk_notebook_set_window_creation_hook_cb,
        cunote, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_print_operation_get_error noargs
static PyObject *
_wrap_gtk_print_operation_get_error(PyGObject *self)
{
    GError *error = NULL;

    gtk_print_operation_get_error(GTK_PRINT_OPERATION(self->obj), &error);

    if (pyg_error_check(&error)) {
        PyObject *type, *value, *traceback;
        PyErr_Fetch(&type, &value, &traceback);
        Py_DECREF(type);
        Py_DECREF(traceback);
        return value;
    }

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override GtkEditable__do_insert_text kwargs
static PyObject *
_wrap_GtkEditable__do_insert_text(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "text", "position", NULL };
    PyGObject *self;
    Py_ssize_t text_len;
    int position;
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s#i:GtkEditable.do_insert_text", kwlist,
                                     &PyGtkEditable_Type, &self,
                                     &text, &text_len, &position))
        return NULL;


    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_EDITABLE_CLASS(klass)->insert_text)
        GTK_EDITABLE_CLASS(klass)->insert_text(GTK_EDITABLE(self->obj),
                                               text, text_len, &position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method GtkEditable.do_insert_text not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    
    return PyLong_FromLong(position);
}

%%
override GtkEditable__do_do_insert_text kwargs
static PyObject *
_wrap_GtkEditable__do_do_insert_text(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "text", "position", NULL };
    PyGObject *self;
    Py_ssize_t text_len;
    int position;
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s#i:GtkEditable.do_do_insert_text", kwlist,
                                     &PyGtkEditable_Type, &self,
                                     &text, &text_len, &position))
        return NULL;


    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_EDITABLE_CLASS(klass)->do_insert_text)
        GTK_EDITABLE_CLASS(klass)->do_insert_text(GTK_EDITABLE(self->obj),
                                                  text, text_len, &position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method GtkEditable.do_do_insert_text not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    
    return PyLong_FromLong(position);
}

%%
override GtkEditable__do_get_selection_bounds kwargs
static PyObject *
_wrap_GtkEditable__do_get_selection_bounds(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int start_pos, end_pos;;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:GtkEditable.do_get_selection_bounds", kwlist,
                                     &PyGtkEditable_Type, &self))
        return NULL;

    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_EDITABLE_CLASS(klass)->get_selection_bounds)
        GTK_EDITABLE_CLASS(klass)->get_selection_bounds(GTK_EDITABLE(self->obj),
                                                        &start_pos, &end_pos);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method GtkEditable.do_get_selection_bounds not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    
    return Py_BuildValue("ii", start_pos, end_pos);
}

%%
define GtkAction.set_menu_item_type kwargs classmethod
static PyObject *
_wrap_gtk_action_set_menu_item_type(PyObject *cls,
                                    PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "menu_item_type", NULL };
    GType gtype, menu_item_type;
    GtkActionClass *klass;
    PyObject *py_menu_item_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.Action.set_menu_item_type", kwlist,
				     &py_menu_item_type))
	return NULL;

    if ((gtype = pyg_type_from_object(cls)) == 0)
        return NULL;

    if (!PyType_Check(py_menu_item_type)
        || !PyType_IsSubtype((PyTypeObject *) py_menu_item_type, &PyGtkMenuItem_Type)) {
        PyErr_SetString(PyExc_TypeError, "argument must be a subtype of gtk.MenuItem");
        return NULL;
    }

    if ((menu_item_type = pyg_type_from_object(py_menu_item_type)) == 0)
        return NULL;

    klass = (GtkActionClass *) g_type_class_ref(gtype);
    klass->menu_item_type = menu_item_type;
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

%%
define GtkAction.set_tool_item_type kwargs classmethod
static PyObject *
_wrap_gtk_action_set_tool_item_type(PyObject *cls,
                                    PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "tool_item_type", NULL };
    GType gtype, tool_item_type;
    GtkActionClass *klass;
    PyObject *py_tool_item_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.Action.set_tool_item_type", kwlist,
				     &py_tool_item_type))
	return NULL;

    if ((gtype = pyg_type_from_object(cls)) == 0)
        return NULL;

    if (!PyType_Check(py_tool_item_type)
        || !PyType_IsSubtype((PyTypeObject *) py_tool_item_type, &PyGtkToolItem_Type)) {
        PyErr_SetString(PyExc_TypeError, "argument must be a subtype of gtk.ToolItem");
        return NULL;
    }

    if ((tool_item_type = pyg_type_from_object(py_tool_item_type)) == 0)
        return NULL;

    klass = (GtkActionClass *) g_type_class_ref(gtype);
    klass->toolbar_item_type = tool_item_type;
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_accel_map_foreach kwargs
static void
pygtk_accel_map_foreach_cb(gpointer data, const gchar *accel_path,
                                guint accel_key, GdkModifierType accel_mode,
                                gboolean changed)
{
    PyGILState_STATE state;
    PyObject *retobj, *py_accel_mode;
    PyGtkCustomNotify *cunote = data;
  
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
    py_accel_mode = pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE, accel_mode);
    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(siNNO)",
                                     accel_path, accel_key, py_accel_mode,
                                     PyBool_FromLong(changed), cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(siNN)", accel_path,
                                     accel_key, py_accel_mode,
                                     PyBool_FromLong(changed));
 
    if (retobj == NULL)
        PyErr_Print();

    Py_XDECREF(retobj);
  
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_accel_map_foreach(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "foreach_func", "data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:gtk.accel_map_foreach",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;
  
    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "foreach_func must be a callable object");
        return NULL;
    }

    cunote.func = pyfunc;
    cunote.data = pyarg;
 
    gtk_accel_map_foreach(&cunote, pygtk_accel_map_foreach_cb);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_accel_map_foreach_unfiltered kwargs
static PyObject *
_wrap_gtk_accel_map_foreach_unfiltered(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "foreach_func", "data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:gtk.accel_map_foreach_unfiltered",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;
  
    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "foreach_func must be a callable object");
        return NULL;
    }

    cunote.func = pyfunc;
    cunote.data = pyarg;
 
    gtk_accel_map_foreach_unfiltered(&cunote, pygtk_accel_map_foreach_cb);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_scale_button_new kwargs
static int
_wrap_gtk_scale_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "size", "min", "max", "step", "icons", NULL };
    PyObject *py_size = NULL, *py_icons = NULL;
    double min, max, step;
    gchar **icons = NULL;
    GtkIconSize size;
    GtkAdjustment *adj;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oddd|O:GtkScaleButton.__init__", kwlist,
                                     &py_size, &min, &max, &step, &py_icons))
        return -1;
    
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return -1;
    
    if (py_icons) {
        if (!PySequence_Check(py_icons)) {
            PyErr_SetString(PyExc_TypeError, "icons must be a sequence");
            return -1;
        }    
        len = PySequence_Length(py_icons);
        icons = g_new(gchar *, len + 1);
        for (i = 0; i < len; i++) {
            PyObject *item = PySequence_GetItem(py_icons, i);
            if (!PyUnicode_Check(item)) {
                PyErr_SetString(PyExc_TypeError, "icon must be a string");
                g_free(icons);
                return -1;
            }
            icons[i] = PyUnicode_AsUTF8(item);
            Py_DECREF(item);
        }
        icons[len] = NULL;
    }
    pygobject_construct(self, "size", size, "icons", icons, NULL);
    
    g_free(icons);
    
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create gtk.ScaleButton object");
        return -1;
    }

    adj = gtk_scale_button_get_adjustment(GTK_SCALE_BUTTON(self->obj));
    g_object_set(adj, "lower", min, "upper", max, "step-increment", step, NULL);

    return 0;
}
%%
new-constructor GTK_TYPE_SCALE_BUTTON
%%
override gtk_scale_button_set_icons kwargs
static PyObject *
_wrap_gtk_scale_button_set_icons(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icons", NULL };
    PyObject *py_icons;
    gchar **icons = NULL;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkScaleButton.set_icons", kwlist,
                                     &py_icons))
        return NULL;

    if (!PySequence_Check(py_icons)) {
        PyErr_SetString(PyExc_TypeError, "icons must be a sequence");
        return NULL;
    }    
    len = PySequence_Length(py_icons);
    icons = g_new(gchar *, len + 1);
    for (i = 0; i < len; i++) {
        PyObject *item = PySequence_GetItem(py_icons, i);
        if (!PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError, "icon must be a string");
            g_free(icons);
            return NULL;
        }
        icons[i] = PyUnicode_AsUTF8(item);
        Py_DECREF(item);
    }
    icons[len] = NULL;

    gtk_scale_button_set_icons(GTK_SCALE_BUTTON(self->obj),
                               (const gchar **) icons);

    g_free(icons);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_cell_layout_get_cells noargs
static PyObject *
_wrap_gtk_cell_layout_get_cells(PyGObject *self)
{
    PyObject    *py_cells;
    GList       *cells, *l;
    
    py_cells = PyList_New(0);
    
    cells = gtk_cell_layout_get_cells(GTK_CELL_LAYOUT(self->obj));

    for (l = cells; l; l = l->next)
    {
        PyObject *item = pygobject_new((GObject *)l->data);
        PyList_Append(py_cells, item);
        Py_DECREF(item);
    }
    g_list_free(cells);

    return py_cells;
}
%%
override gtk_icon_theme_list_contexts noargs
static PyObject *
_wrap_gtk_icon_theme_list_contexts(PyGObject *self)
{
    GList   *contexts;
    int i;
    guint len;
    PyObject *py_contexts;

    contexts = gtk_icon_theme_list_contexts(GTK_ICON_THEME(self->obj));
    len = g_list_length(contexts);

    py_contexts = PyTuple_New(len);

    for (i = 0; i < len; i++) {
        char *name = (char *)g_list_nth_data(contexts, i);

        PyTuple_SetItem(py_contexts, i, PyUnicode_FromString(name));
    }
    g_list_foreach(contexts, (GFunc)g_free, NULL);
    g_list_free(contexts);

    return py_contexts;
}
%%
override gtk_icon_theme_choose_icon kwargs
static PyObject *
_wrap_gtk_icon_theme_choose_icon(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char         *kwlist[] = { "icon_names", "size", "flags", NULL };
    int                 i, len;
    gint                size;
    PyObject            *py_icons, *py_flags = NULL;
    gchar               **icon_names;
    GtkIconLookupFlags  flags;
    GtkIconInfo         *ret;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,
                                     "OiO:GtkIconTheme.choose_icon",
                                     kwlist, &py_icons, &size, &py_flags))
        return NULL;

    if (!PySequence_Check(py_icons) || (len = PySequence_Size(py_icons)) < 0) {
        PyErr_SetString(PyExc_ValueError,
                        "icon_names should be a sequence of strings");
        return NULL;
    }
    
    if (pyg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS,
                            py_flags, (gpointer)&flags))
        return NULL;

    icon_names = g_new(gchar *, len + 1);
    for (i = 0; i < len; i++) {
        PyObject *item = PySequence_GetItem(py_icons, i);
        if (!item) {
            g_free(icon_names);
            return NULL;
        }
        if (!PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError, "icon must be a string");
            g_free(icon_names);
            Py_DECREF(item);
            return NULL;
        }
        icon_names[i] = PyUnicode_AsUTF8(item);
        Py_DECREF(item);
    }
    icon_names[len] = NULL;

    ret = gtk_icon_theme_choose_icon(GTK_ICON_THEME(self->obj),
                                     (const gchar **)icon_names, size, flags);

    g_free(icon_names);
    return pyg_boxed_new(GTK_TYPE_ICON_INFO, ret, TRUE, TRUE);
}
%%
override-attr GtkBin.child
static int
_wrap_gtk_bin__set_child(PyGObject *self, PyGObject *value, void *closure)
{
    if (!pygobject_check(value, &PyGtkWidget_Type) &&
	(PyObject*)value != Py_None) {
	PyErr_SetString(PyExc_TypeError, "must be a GtkWidget object");
	return -1;
    }

    if ((PyObject*)value == Py_None)
	GTK_BIN(self->obj)->child = NULL;
    else
	GTK_BIN(self->obj)->child = g_object_ref(GTK_WIDGET(value->obj));

    return 0;
}
%%
define GtkFileChooserDialog.get_action noargs
/* This is a Workaround to solve a problem in the __mro__ of FileChooserDialog,
 * without this method a gtk.Widget method  with the same name will be called
 * which will always return None, see bug 534042.
 */
static PyObject *
_wrap_gtk_file_chooser_dialog_get_action(PyGObject *self)
{
   gint ret;

   ret = gtk_file_chooser_get_action(GTK_FILE_CHOOSER(self->obj));

   return pyg_enum_from_gtype(GTK_TYPE_FILE_CHOOSER_ACTION, ret);

}
%%
override-attr GtkMessageDialog.image
static PyObject *
_wrap_gtk_message_dialog__get_image(PyObject *self, void *closure)
{
    GtkWidget *ret;
    
    if (PyErr_Warn(PyExc_DeprecationWarning,
                   "use set_image() instead") < 0)
        return NULL;
    
    ret = GTK_MESSAGE_DIALOG(pygobject_get(self))->image;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
%%
override-attr GtkMessageDialog.label
static PyObject *
_wrap_gtk_message_dialog__get_label(PyObject *self, void *closure)
{
    GtkWidget *ret;
    
    if (PyErr_Warn(PyExc_DeprecationWarning,
                   "use set_markup() instead") < 0)
        return NULL;

    ret = GTK_MESSAGE_DIALOG(pygobject_get(self))->label;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
%%
override gtk_hsv_get_color noargs
static PyObject *
_wrap_gtk_hsv_get_color(PyGObject *self)
{
    gdouble h, s, v;

    gtk_hsv_get_color(GTK_HSV(self->obj), &h, &s, &v);

    return Py_BuildValue("(ddd)", h, s, v);
}
%%
override gtk_hsv_get_metrics noargs
static PyObject *
_wrap_gtk_hsv_get_metrics(PyGObject *self)
{
    gint size, ring_width;

    gtk_hsv_get_metrics(GTK_HSV(self->obj), &size, &ring_width);

    return Py_BuildValue("(ii)", size, ring_width);
}
%%
override gtk_hsv_to_rgb kwargs
static PyObject *
_wrap_gtk_hsv_to_rgb(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "h", "s", "v", NULL };
    gdouble h=0, s=0, v=0;
    gdouble r, g, b;
    
    if (!PyArg_ParseTupleAndKeywords(args,kwargs,
                                     "ddd:gtk.hsv_to_rgb",
                                     kwlist, &h, &s, &v))
        return NULL;
    
    gtk_hsv_to_rgb(h, s, v, &r, &g, &b);

    return Py_BuildValue("(ddd)", r, g, b);
}
%%
override gtk_cell_renderer_get_alignment noargs
static PyObject *
_wrap_gtk_cell_renderer_get_alignment(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_cell_renderer_get_alignment(GTK_CELL_RENDERER(self->obj),
                                    &xalign, &yalign);

    return Py_BuildValue("(dd)", xalign, yalign);
}
%%
override gtk_cell_renderer_get_padding noargs
static PyObject *
_wrap_gtk_cell_renderer_get_padding(PyGObject *self)
{
    gint xpad, ypad;

    gtk_cell_renderer_get_padding(GTK_CELL_RENDERER(self->obj), &xpad, &ypad);

    return Py_BuildValue("(ii)", xpad, ypad);
}
%%
override gtk_widget_set_allocation kwargs
static PyObject *
_wrap_gtk_widget_set_allocation(PyGObject *self,
                                PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "allocation", NULL };
    PyObject *py_allocation;
    GdkRectangle allocation = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.set_allocation",
                                     kwlist, &py_allocation))
        return NULL;

    if (!pygdk_rectangle_from_pyobject(py_allocation, &allocation))
        return NULL;
    
    gtk_widget_set_allocation(GTK_WIDGET(self->obj), &allocation);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_wait_for_uris noargs
static PyObject *
_wrap_gtk_clipboard_wait_for_uris(PyGObject *self)
{
    gchar **uris = NULL, **tmp;
    PyObject *ret;
    int i = 0, j;

    uris = gtk_clipboard_wait_for_uris(GTK_CLIPBOARD(self->obj));

    if (uris) {
        tmp = uris;
        while (*tmp)
            tmp++, i++;

        ret = PyTuple_New(i);
        for (j = 0; j < i; j++)
            PyTuple_SetItem(ret, j, PyUnicode_FromString(uris[j]));

        g_strfreev(uris);

        return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
